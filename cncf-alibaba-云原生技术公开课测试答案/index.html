<!doctype html><html lang=zh-cn><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=robots content="noodp"><meta http-equiv=x-ua-compatible content="IE=edge, chrome=1"><title>CNCF × Alibaba 云原生技术公开课测试答案 - 实用后端技术</title><meta name=Description content="实用后端技术"><meta property="og:title" content="CNCF × Alibaba 云原生技术公开课测试答案"><meta property="og:description" content="https://edu.aliyun.com/roadmap/cloudnative 第 1 讲：第一堂 “云原生” 课 3. (单选) 我编写的容器化应用，会将日志文件写在某路径写死的目录里。请问这破坏了云原生理念了吗 正确答案： B. 是 第 2 讲"><meta property="og:type" content="article"><meta property="og:url" content="https://www.elonzh.com/cncf-alibaba-%E4%BA%91%E5%8E%9F%E7%94%9F%E6%8A%80%E6%9C%AF%E5%85%AC%E5%BC%80%E8%AF%BE%E6%B5%8B%E8%AF%95%E7%AD%94%E6%A1%88/"><meta property="og:image" content="https://www.elonzh.com/logo.png"><meta property="article:published_time" content="2019-11-14T00:00:00+00:00"><meta property="article:modified_time" content="2019-11-14T00:00:00+00:00"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://www.elonzh.com/logo.png"><meta name=twitter:title content="CNCF × Alibaba 云原生技术公开课测试答案"><meta name=twitter:description content="https://edu.aliyun.com/roadmap/cloudnative 第 1 讲：第一堂 “云原生” 课 3. (单选) 我编写的容器化应用，会将日志文件写在某路径写死的目录里。请问这破坏了云原生理念了吗 正确答案： B. 是 第 2 讲"><meta name=application-name content="LoveIt"><meta name=apple-mobile-web-app-title content="LoveIt"><meta name=theme-color content="#ffffff"><meta name=msapplication-TileColor content="#da532c"><link rel="shortcut icon" type=image/x-icon href=https://www.elonzh.com/favicon.ico><link rel=icon type=image/png sizes=32x32 href=https://www.elonzh.com/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=https://www.elonzh.com/favicon-16x16.png><link rel=apple-touch-icon sizes=180x180 href=https://www.elonzh.com/apple-touch-icon.png><link rel=mask-icon href=https://www.elonzh.com/safari-pinned-tab.svg color=#5bbad5><link rel=manifest href=https://www.elonzh.com/site.webmanifest><link rel=canonical href=https://www.elonzh.com/cncf-alibaba-%E4%BA%91%E5%8E%9F%E7%94%9F%E6%8A%80%E6%9C%AF%E5%85%AC%E5%BC%80%E8%AF%BE%E6%B5%8B%E8%AF%95%E7%AD%94%E6%A1%88/><link rel=prev href=https://www.elonzh.com/peeweext-%E6%97%A5%E6%9C%9F%E6%97%B6%E9%97%B4%E6%88%B3%E7%B2%BE%E5%BA%A6%E4%B8%A2%E5%A4%B1%E9%97%AE%E9%A2%98/><link rel=next href=https://www.elonzh.com/celery-%E6%98%AF%E5%A6%82%E4%BD%95%E8%B7%AF%E7%94%B1%E6%B6%88%E6%81%AF%E7%9A%84/><link rel=stylesheet href=https://www.elonzh.com/lib/normalize/normalize.min.css><link rel=stylesheet href=https://www.elonzh.com/css/style.min.css><link rel=stylesheet href=https://www.elonzh.com/lib/fontawesome-free/all.min.css><link rel=stylesheet href=https://www.elonzh.com/lib/animate/animate.min.css><script type=application/ld+json>{"@context":"http://schema.org","@type":"BlogPosting","headline":"CNCF × Alibaba 云原生技术公开课测试答案","inLanguage":"zh-cn","mainEntityOfPage":{"@type":"WebPage","@id":"https:\/\/www.elonzh.com\/cncf-alibaba-%E4%BA%91%E5%8E%9F%E7%94%9F%E6%8A%80%E6%9C%AF%E5%85%AC%E5%BC%80%E8%AF%BE%E6%B5%8B%E8%AF%95%E7%AD%94%E6%A1%88\/"},"genre":"posts","keywords":"CNCF, CKA","wordcount":10351,"url":"https:\/\/www.elonzh.com\/cncf-alibaba-%E4%BA%91%E5%8E%9F%E7%94%9F%E6%8A%80%E6%9C%AF%E5%85%AC%E5%BC%80%E8%AF%BE%E6%B5%8B%E8%AF%95%E7%AD%94%E6%A1%88\/","datePublished":"2019-11-14T00:00:00+00:00","dateModified":"2019-11-14T00:00:00+00:00","publisher":{"@type":"Organization","name":""},"author":{"@type":"Person","name":"Elon Zhou"},"description":""}</script></head><body header-desktop=fixed header-mobile=auto><script type=text/javascript>(window.localStorage&&localStorage.getItem('theme')?localStorage.getItem('theme')==='dark':('auto'==='auto'?window.matchMedia('(prefers-color-scheme: dark)').matches:'auto'==='dark'))&&document.body.setAttribute('theme','dark');</script><div id=mask></div><div class=wrapper><header class=desktop id=header-desktop><div class=header-wrapper><div class=header-title><a href=https://www.elonzh.com/ title=实用后端技术></a></div><div class=menu><div class=menu-inner><a class=menu-item href=https://www.elonzh.com/>首页 </a><a class=menu-item href=https://www.elonzh.com/posts/>文章 </a><a class=menu-item href=https://www.elonzh.com/tags/>标签 </a><a class=menu-item href=https://www.elonzh.com/categories/>分类 </a><a class=menu-item href=https://www.elonzh.com/snippet/>代码片 </a><a class=menu-item href=https://www.elonzh.com/about/>关于 </a><span class="menu-item delimiter"></span><span class="menu-item search" id=search-desktop><input type=text placeholder=搜索文章标题或内容... id=search-input-desktop>
<a href=javascript:void(0); class="search-button search-toggle" id=search-toggle-desktop title=搜索><i class="fas fa-search fa-fw"></i></a><a href=javascript:void(0); class="search-button search-clear" id=search-clear-desktop title=清空><i class="fas fa-times-circle fa-fw"></i></a><span class="search-button search-loading" id=search-loading-desktop><i class="fas fa-spinner fa-fw fa-spin"></i></span></span><a href=javascript:void(0); class="menu-item theme-switch" title=切换主题><i class="fas fa-adjust fa-fw"></i></a></div></div></div></header><header class=mobile id=header-mobile><div class=header-container><div class=header-wrapper><div class=header-title><a href=https://www.elonzh.com/ title=实用后端技术></a></div><div class=menu-toggle id=menu-toggle-mobile><span></span><span></span><span></span></div></div><div class=menu id=menu-mobile><div class=search-wrapper><div class="search mobile" id=search-mobile><input type=text placeholder=搜索文章标题或内容... id=search-input-mobile>
<a href=javascript:void(0); class="search-button search-toggle" id=search-toggle-mobile title=搜索><i class="fas fa-search fa-fw"></i></a><a href=javascript:void(0); class="search-button search-clear" id=search-clear-mobile title=清空><i class="fas fa-times-circle fa-fw"></i></a><span class="search-button search-loading" id=search-loading-mobile><i class="fas fa-spinner fa-fw fa-spin"></i></span></div><a href=javascript:void(0); class=search-cancel id=search-cancel-mobile>取消</a></div><a class=menu-item href=https://www.elonzh.com/>首页</a><a class=menu-item href=https://www.elonzh.com/posts/>文章</a><a class=menu-item href=https://www.elonzh.com/tags/>标签</a><a class=menu-item href=https://www.elonzh.com/categories/>分类</a><a class=menu-item href=https://www.elonzh.com/snippet/>代码片</a><a class=menu-item href=https://www.elonzh.com/about/>关于</a><a href=javascript:void(0); class="menu-item theme-switch" title=切换主题>
<i class="fas fa-adjust fa-fw"></i></a></div></div></header><div class="search-dropdown desktop"><div id=search-dropdown-desktop></div></div><div class="search-dropdown mobile"><div id=search-dropdown-mobile></div></div><main class=main><div class=container><div class=toc id=toc-auto><h2 class=toc-title>目录</h2><div class=toc-content id=toc-content-auto></div></div><article class="page single"><h1 class="single-title animated flipInX">CNCF × Alibaba 云原生技术公开课测试答案</h1><div class=post-meta><div class=post-meta-line><span class=post-author><a href=https://www.elonzh.com/ title=Author rel=author class=author><i class="fas fa-user-circle fa-fw"></i>Elon Zhou</a></span>&nbsp;<span class=post-category>收录于 <a href=https://www.elonzh.com/categories/%E4%BA%91%E5%8E%9F%E7%94%9F/><i class="far fa-folder fa-fw"></i>云原生</a></span></div><div class=post-meta-line><i class="far fa-calendar-alt fa-fw"></i>&nbsp;<time datetime=2019-11-14>2019-11-14</time>&nbsp;<i class="fas fa-pencil-alt fa-fw"></i>&nbsp;约 10351 字&nbsp;
<i class="far fa-clock fa-fw"></i>&nbsp;预计阅读 21 分钟&nbsp;</div></div><div class="details toc" id=toc-static kept><div class="details-summary toc-title"><span>目录</span>
<span><i class="details-icon fas fa-angle-right"></i></span></div><div class="details-content toc-content" id=toc-content-static><nav id=TableOfContents><ul><li><ul><li><a href=#第-1-讲第一堂-云原生-课>第 1 讲：第一堂 “云原生” 课</a><ul><li><a href=#3-单选-我编写的容器化应用会将日志文件写在某路径写死的目录里请问这破坏了云原生理念了吗>3. (单选) 我编写的容器化应用，会将日志文件写在某路径写死的目录里。请问这破坏了云原生理念了吗</a></li></ul></li><li><a href=#第-2-讲容器基本概念>第 2 讲：容器基本概念</a><ul><li><a href=#5-已运行-docker-run--d--t-name-demo-ubuntu-top-命令-是否可以在-demo-这个容器内部停止容器>5. 已运行 docker run -d -t —name demo ubuntu top 命令, 是否可以在 demo 这个容器内部停止容器</a></li><li><a href=#8-已运行-docker-run--d--t-name-demo-ubuntu-top-和-docker-run---name-demo-x---pid-containerdemo-ubuntu-ps-命令是否可以在-demo-x-容器内部停止容器>8. 已运行 docker run -d -t —name demo ubuntu top 和 docker run &ndash;name demo-x &ndash;pid container:demo ubuntu ps 命令，是否可以在 demo-x 容器内部停止容器</a></li></ul></li><li><a href=#第-3-讲kubernetes-核心概念>第 3 讲：Kubernetes 核心概念</a><ul><li><a href=#3-scheduler-的主要功能是________>3. Scheduler 的主要功能是________</a></li><li><a href=#10-属于-node-上的基本组件有________>10. 属于 Node 上的基本组件有________</a></li></ul></li><li><a href=#第-4-讲理解-pod-和容器设计模式>第 4 讲：理解 Pod 和容器设计模式</a><ul><li><a href=#3-一个-pod-里-infra-container-的启动顺序是>3. 一个 Pod 里 Infra Container 的启动顺序是</a></li><li><a href=#8-如果没有-pod-概念但我要用多个容器模拟-pod-的话可能需要做哪些工作>8. 如果没有 Pod 概念，但我要用多个容器模拟 Pod 的话，可能需要做哪些工作</a></li><li><a href=#9-关于-google-borg-论文论述正确的是>9. 关于 Google Borg 论文论述正确的是</a></li></ul></li><li><a href=#第-5-讲应用编排与管理---核心原理>第 5 讲：应用编排与管理 - 核心原理</a><ul><li><a href=#1-controller-中的-workerqueue-中可以存放什么内容>1. Controller 中的 workerqueue 中可以存放什么内容</a></li><li><a href=#2-controller-中的-object-store-默认以什么作为索引>2. Controller 中的 object store 默认以什么作为索引</a></li><li><a href=#7-在-controller-的-event-handler-中-不适合执行的操作是>7. 在 controller 的 event handler 中， 不适合执行的操作是</a></li><li><a href=#8-下列关于-controller-中-workqueue-描述不正确的>8. 下列关于 controller 中 workqueue 描述不正确的</a></li><li><a href=#10-以下不是声明式的-api-设计>10. 以下不是声明式的 API 设计</a></li></ul></li><li><a href=#第-6-讲应用编排与管理---deployment>第 6 讲：应用编排与管理 - Deployment</a><ul><li><a href=#2-关于-maxunavailable-以下说法正确的是>2. 关于 MaxUnavailable 以下说法正确的是：</a></li><li><a href=#8-deployment-与-replicaset-的关系与以下哪组资源最像>8. Deployment 与 ReplicaSet 的关系与以下哪组资源最像</a></li><li><a href=#9-以下关于-deployment-的说法正确的有哪些>9. 以下关于 Deployment 的说法正确的有哪些</a></li><li><a href=#10-指定-deployment-回滚到某个历史版本执行成功的过程中不会发生以下哪些事件>10. 指定 Deployment 回滚到某个历史版本执行成功的过程中，不会发生以下哪些事件：</a></li></ul></li><li><a href=#第-7-讲应用编排与管理---job-和-daemonset>第 7 讲：应用编排与管理 - Job 和 DaemonSet</a><ul><li><a href=#9-使用哪些标签能让-daemonset-的-pod-只运行在某些节点>9. 使用哪些标签能让 daemonset 的 pod 只运行在某些节点</a></li></ul></li><li><a href=#第-8-讲应用配置管理>第 8 讲：应用配置管理</a><ul><li><a href=#6-当节点磁盘空间不足时pod-被驱逐的顺序为-besteffort-先于-burstable>6. 当节点磁盘空间不足时，Pod 被驱逐的顺序为: BestEffort 先于 Burstable</a></li><li><a href=#10-如下哪些方式创建的-pod-可以使用-configmap>10. 如下哪些方式创建的 Pod 可以使用 ConfigMap</a></li></ul></li><li><a href=#第-9-讲应用存储和持久化数据卷---核心知识>第 9 讲：应用存储和持久化数据卷 - 核心知识</a><ul><li><a href=#5-在-pod-中声明使用-volume-需要配置哪些字段>5. 在 Pod 中声明使用 volume 需要配置哪些字段</a></li><li><a href=#6-在-pod-中声明使用-volume-常见类型>6. 在 Pod 中声明使用 volume 常见类型</a></li></ul></li><li><a href=#第-10-讲应用存储和持久化数据卷---存储快照与拓扑调度>第 10 讲：应用存储和持久化数据卷 - 存储快照与拓扑调度</a><ul><li><a href=#3-下面在-kube-scheduler-中结合-pod-中声明的-pvcs-选择-node-过程描述正确的有>3. 下面在 Kube-Scheduler 中结合 Pod 中声明的 PVCs 选择 Node 过程描述正确的有</a></li><li><a href=#4-kubernetes-中为了支持存储拓扑调度相关组件做的改变有>4. Kubernetes 中为了支持存储拓扑调度相关组件做的改变有</a></li><li><a href=#5-下列有关使用存储拓扑调度时对-storageclass-的配置正确的有>5. 下列有关使用存储拓扑调度时对 StorageClass 的配置正确的有</a></li><li><a href=#7-可以限制-pv-对象可被访问拓扑位置限制的地方>7. 可以限制 PV 对象可被访问拓扑位置限制的地方</a></li><li><a href=#8-下列有关如何使用存储拓扑调度的说法正确的有>8. 下列有关如何使用存储拓扑调度的说法正确的有</a></li><li><a href=#9-使用存储快照功能需要用到哪些-kubernetes-api-资源对象>9. 使用存储快照功能需要用到哪些 Kubernetes API 资源对象</a></li></ul></li><li><a href=#第-11-讲可观测性你的应用健康吗>第 11 讲：可观测性——你的应用健康吗</a><ul><li><a href=#4-readiness-probe-可以解决应用启动慢造成访问异常的问题>4. Readiness Probe 可以解决应用启动慢造成访问异常的问题。</a></li><li><a href=#7-当-pod-处在-pending-的时候可能是由于如下哪个问题造成的>7. 当 Pod 处在 Pending 的时候，可能是由于如下哪个问题造成的。</a></li><li><a href=#9-以下哪个关于-liveness-probe-的描述是错误的>9. 以下哪个关于 Liveness Probe 的描述是错误的</a></li></ul></li><li><a href=#第-12-讲可观测性监控与日志>第 12 讲：可观测性——监控与日志</a><ul><li><a href=#2-以下哪个不是-prometheus-的优势>2. 以下哪个不是 Prometheus 的优势</a></li></ul></li><li><a href=#第-13-讲kubernetes-网络概念及策略控制>第 13 讲：Kubernetes 网络概念及策略控制</a><ul><li><a href=#1-影响容器网络性能最关键的因素是哪个>1. 影响容器网络性能最关键的因素是哪个</a></li><li><a href=#3-哪种容器网络方案是普适性最高的默认选择>3. 哪种容器网络方案是普适性最高的默认选择</a></li><li><a href=#5-net-namespace-拥有完全独立隔离的网络环境>5. net namespace 拥有完全独立隔离的网络环境。</a></li><li><a href=#6-kubernetes-的-pod-只能有且只能配置-1-个-ip-地址>6. Kubernetes 的 Pod 只能有且只能配置 1 个 IP 地址。</a></li><li><a href=#7-kubernetes-network-policy-只支持-tcpudp-作为协议字段值>7. Kubernetes network policy 只支持 TCP/UDP 作为协议字段值。</a></li><li><a href=#8-kubernetes-容器网络方案实现上禁止任何形式的地址转换nat>8. Kubernetes 容器网络方案实现上，禁止任何形式的地址转换（NAT）。</a></li><li><a href=#9-kubernetes-基本网络模型需要符合哪些条件>9. Kubernetes 基本网络模型需要符合哪些条件</a></li><li><a href=#10-kubernetes-网络方案需要考虑哪些需要达成的连通性目标>10. Kubernetes 网络方案需要考虑哪些需要达成的连通性目标</a></li></ul></li><li><a href=#第-14-讲kubernetes-services>第 14 讲：Kubernetes Services</a><ul><li><a href=#5-创建-loadbalancer-类型的-service-会自动创建和绑定外部-loadbalancer-到节点映射的-nodeport-上>5. 创建 LoadBalancer 类型的 Service 会自动创建和绑定外部 LoadBalancer 到节点映射的 NodePort 上。</a></li><li><a href=#8-pod-可以直接用-service-名来访问同一个集群里的-service不管-pod-和-service-在不在一个-namespace>8. Pod 可以直接用 Service 名来访问同一个集群里的 Service，不管 Pod 和 Service 在不在一个 Namespace。</a></li></ul></li><li><a href=#第-15-讲深入剖析-linux-容器>第 15 讲：深入剖析 Linux 容器</a><ul><li><a href=#3-docker-在宿主机上最多可以创建多少个容器>3. docker 在宿主机上最多可以创建多少个容器</a></li><li><a href=#4-宿主机上能否看见容器内的进程>4. 宿主机上能否看见容器内的进程</a></li><li><a href=#7-运行-docker-stop-container-命令停止一个容器后容器的相关文件还在吗>7. 运行 docker stop $container 命令停止一个容器后，容器的相关文件还在吗</a></li><li><a href=#8-已运行-docker-run--d--t---name-demo-ubuntu-top-和-docker-run---name-demo-x---pid-containerdemo-ubuntu-ps-命令是否可以在-demo-x-容器内停止容器>8. 已运行 docker run -d -t &ndash;name demo ubuntu top 和 docker run &ndash;name demo-x &ndash;pid container:demo ubuntu ps 命令，是否可以在 demo-x 容器内停止容器</a></li><li><a href=#9-已运行-docker-run--d--t---name-demo-ubuntu-top-命令-是否在-demo-这个容器内部停止容器>9. 已运行 docker run -d -t &ndash;name demo ubuntu top 命令, 是否在 demo 这个容器内部停止容器</a></li><li><a href=#10-已运行-docker-run--d--t---name-demo-ubuntu-top-和-docker-run---name-demo-x---pid-containerdemo-ubuntu-ps-命令如果-demo-容器退出了正在运行的-demo-x-容器是否会退出>10. 已运行 docker run -d -t &ndash;name demo ubuntu top 和 docker run &ndash;name demo-x &ndash;pid container:demo ubuntu ps 命令，如果 demo 容器退出了，正在运行的 demo-x 容器是否会退出</a></li></ul></li><li><a href=#理解-etcd-的核心设计思想>理解 etcd 的核心设计思想</a><ul><li><a href=#6-etcd-集群中存在-3-个-server-时重启其中一个-server-完全不会影响服务>6. etcd 集群中存在 3 个 server 时，重启其中一个 server 完全不会影响服务。</a></li><li><a href=#9-关于-etcd-lease以下说法正确的是>9. 关于 etcd lease，以下说法正确的是</a></li></ul></li><li><a href=#第-17-讲深入理解-etcd---etcd-性能优化实践>第 17 讲：深入理解 etcd - etcd 性能优化实践</a><ul><li><a href=#5-etcd-满足了-cap-原理中的哪些特性>5. etcd 满足了 CAP 原理中的哪些特性</a></li><li><a href=#8-以下说法正确的是>8. 以下说法正确的是</a></li><li><a href=#10-关于-etcd-lease以下说法正确的是>10. 关于 etcd lease，以下说法正确的是</a></li></ul></li><li><a href=#第-18-讲kubernetes-调度和资源管理>第 18 讲：Kubernetes 调度和资源管理</a><ul><li><a href=#1-挑选一个合适节点作为抢占节点的策略当中哪个因素是排在第一位的考虑因素>1. 挑选一个合适节点作为抢占节点的策略当中，哪个因素是排在第一位的考虑因素</a></li><li><a href=#7-在资源列表中-15gi-内存也可以用以下哪个方式表达>7. 在资源列表中 1.5Gi 内存也可以用以下哪个方式表达</a></li><li><a href=#10-下列哪种-requestlimit-使用方式代表创建-burstable-的-pod>10. 下列哪种 request/limit 使用方式代表创建 Burstable 的 Pod</a></li></ul></li><li><a href=#第-19-讲调度器的调度流程和算法介绍>第 19 讲：调度器的调度流程和算法介绍</a><ul><li><a href=#1-下列关于打分器prioritize的作用描述不正确的是>1. 下列关于打分器（prioritize）的作用描述不正确的是</a></li><li><a href=#4-以下扩展点哪个是-scheduler-extender-不支持的>4. 以下扩展点哪个是 scheduler extender 不支持的</a></li><li><a href=#6-调度节点选择的逻辑是>6. 调度节点选择的逻辑是</a></li></ul></li><li><a href=#第-20-讲gpu-管理和-device-plugin-工作机制>第 20 讲：GPU 管理和 Device Plugin 工作机制</a><ul><li><a href=#1device-plugin-的-allocateresponse-中可以接收如下哪些参数>1.Device Plugin 的 AllocateResponse 中可以接收如下哪些参数</a></li><li><a href=#2device-plugin-中-api-可以用来反映设备健康状况的方法名称是>2.Device Plugin 中 API 可以用来反映设备健康状况的方法名称是</a></li><li><a href=#3kubernetes-是从哪个版本开始支持-device-plugin>3.Kubernetes 是从哪个版本开始支持 Device Plugin</a></li><li><a href=#4-使用-kubernetes-管理-gpu-资源可以利用-kubernetes-的统一调度能力使资源使用方能够用即申请完即释放从而盘活整个-gpu-资源池>4. 使用 Kubernetes 管理 GPU 资源可以利用 Kubernetes 的统一调度能力，使资源使用方能够用即申请，完即释放，从而盘活整个 GPU 资源池。</a></li><li><a href=#5-如果需要构建-gpu-容器镜像必须要在镜像里安装英伟达驱动cuda-库>5. 如果需要构建 GPU 容器镜像，必须要在镜像里安装英伟达驱动、CUDA 库。</a></li><li><a href=#6-必须要使用-nvidia-docker-才能运行-gpu-容器>6. 必须要使用 Nvidia Docker 才能运行 GPU 容器。</a></li><li><a href=#7-可以通过-nvidiacomgpu05-申请-gpu>7. 可以通过 nvidia.com/gpu=0.5 申请 GPU。</a></li><li><a href=#8device-plugin-机制只能支持-nvidia-gpu而无法支持-amd-gpu>8.Device Plugin 机制只能支持 Nvidia GPU，而无法支持 AMD GPU。</a></li><li><a href=#9-当前-kubernetes-先可以支持复杂场景的-gpu-调度比如-gpu-精细调度具体来说可以调度彼此间有-nvlink-连接的两个-gpu-卡>9. 当前 Kubernetes 先可以支持复杂场景的 GPU 调度，比如 GPU 精细调度，具体来说可以调度彼此间有 NVLink 连接的两个 GPU 卡。</a></li><li><a href=#10kubernetes-通过哪些内部机制支持-gpu-管理>10.Kubernetes 通过哪些内部机制支持 GPU 管理</a></li></ul></li><li><a href=#第-21-讲kubernetes-存储架构及插件使用>第 21 讲：Kubernetes 存储架构及插件使用</a><ul><li><a href=#1-下面哪个不是-csi-crd-定义的对象>1. 下面哪个不是 CSI CRD 定义的对象</a></li><li><a href=#2-关于-volume-的-provisionattachmount-操作下面说法错误的是>2. 关于 Volume 的 Provision、Attach、Mount 操作，下面说法错误的是</a></li><li><a href=#3-关于存储卷回收策略下面说法错误的是>3. 关于存储卷回收策略，下面说法错误的是</a></li><li><a href=#4-关于-kubernetes-volumeplugin下面说法错误的是>4. 关于 Kubernetes VolumePlugin，下面说法错误的是</a></li><li><a href=#5-关于-flexvolume-接口下面说法正确的是>5. 关于 Flexvolume 接口，下面说法正确的是</a></li><li><a href=#6-关于-flexvolumecsi下面说法正确的有>6. 关于 Flexvolume、CSI，下面说法正确的有</a></li><li><a href=#7-关于-flexvolume下面说法正确的有>7. 关于 Flexvolume，下面说法正确的有</a></li><li><a href=#8-关于-csi-组件下面说法正确的有>8. 关于 CSI 组件，下面说法正确的有</a></li><li><a href=#9-关于-pvpvc-绑定下面说法正确的有>9. 关于 pv、pvc 绑定，下面说法正确的有</a></li><li><a href=#10-关于-csi下面说法正确的有>10. 关于 CSI，下面说法正确的有</a></li></ul></li><li><a href=#第-22-讲有状态应用编排statefulset>第 22 讲：有状态应用编排：StatefulSet</a><ul><li><a href=#1-通过-statefulset-不能实现以下哪个功能>1. 通过 StatefulSet 不能实现以下哪个功能</a></li><li><a href=#2-创建-statefulset-spec-中的-template-字段用处不包括>2. 创建 StatefulSet spec 中的 template 字段，用处不包括</a></li><li><a href=#3-以下哪个是-statefulset-中要填写-servicename-的根本原因>3. 以下哪个是 StatefulSet 中要填写 serviceName 的根本原因</a></li><li><a href=#4-如果-statefulset-的-podmanagementpolicy-设置为-parallel则下列哪个说法错误>4. 如果 StatefulSet 的 podManagementPolicy 设置为 Parallel，则下列哪个说法错误</a></li><li><a href=#5-以下关于-controllerrevision-历史版本说法正确的是>5. 以下关于 ControllerRevision 历史版本说法正确的是</a></li><li><a href=#6-以下哪个不可能是名为-nginx-web-的-statefulset-扩容出来的-podpvc-name>6. 以下哪个不可能是名为 nginx-web 的 StatefulSet 扩容出来的 pod/pvc name</a></li><li><a href=#7-通过配置-statefulset可以使每个-pod-对应一个独立的-pvc也可以使所有-pod-共用一个-pvc>7. 通过配置 StatefulSet，可以使每个 Pod 对应一个独立的 PVC，也可以使所有 Pod 共用一个 PVC。</a></li><li><a href=#8-关于-statefulset-中的-volumeclaimtemplates下列说法错误的有哪些>8. 关于 StatefulSet 中的 volumeClaimTemplates，下列说法错误的有哪些</a></li><li><a href=#9-以下关于-statefulset-和-deployment-的区别说法正确的有哪些>9. 以下关于 StatefulSet 和 Deployment 的区别说法正确的有哪些</a></li><li><a href=#10-一个-replicas10partition8-的-statefulset在某一个时刻-status-可能处于以下哪些状态>10. 一个 replicas=10、partition=8 的 StatefulSet，在某一个时刻 status 可能处于以下哪些状态</a></li></ul></li><li><a href=#第-23-讲kubernetes-api-编程范式>第 23 讲：Kubernetes API 编程范式</a><ul><li><a href=#1kubernetes-crd-是在哪个版本被引入的>1.Kubernetes CRD 是在哪个版本被引入的</a></li><li><a href=#2-自定义资源使用什么字段来嵌套其他子资源>2. 自定义资源使用什么字段来嵌套其他子资源</a></li><li><a href=#3-自定义资源能够具备自己的状态字段吗>3. 自定义资源能够具备自己的状态字段吗</a></li><li><a href=#4kubernetes-自定义资源一般指的是>4.Kubernetes 自定义资源一般指的是</a></li><li><a href=#5crd-必须配合-controller-才能有效果>5.CRD 必须配合 controller 才能有效果。</a></li><li><a href=#6kubernetes-自定义资源出现的原因是什么>6.Kubernetes 自定义资源出现的原因是什么</a></li><li><a href=#7kubernetes-crd-可以和内置资源共享什么资源>7.Kubernetes CRD 可以和内置资源共享什么资源</a></li><li><a href=#8controller-通过-来同时处理多个对象的请求>8.Controller 通过（ ）来同时处理多个对象的请求</a></li><li><a href=#9-关于-controller-的描述以下正确的有>9. 关于 Controller 的描述，以下正确的有</a></li><li><a href=#10controller-一般具备哪几个函数来接受请求>10.Controller 一般具备哪几个函数来接受请求</a></li></ul></li><li><a href=#第-24-讲kubernetes-api-编程利器operator-和-operator-framework>第 24 讲：Kubernetes API 编程利器：Operator 和 Operator Framework</a><ul><li><a href=#1-在-webhook-业务逻辑中下列哪些行为是不建议的>1. 在 webhook 业务逻辑中，下列哪些行为是不建议的</a></li><li><a href=#2-在-controller-入队逻辑中下列哪些行为是不建议的>2. 在 controller 入队逻辑中，下列哪些行为是不建议的</a></li><li><a href=#3-大多数情况下只能工作在主备模式的是>3. 大多数情况下只能工作在主备模式的是</a></li><li><a href=#4controller-入队逻辑针对可能丢失事件的正确处理方法是什么>4.controller 入队逻辑针对可能丢失事件的正确处理方法是什么</a></li><li><a href=#5webhook-只能拦截处理-crd-对象>5.webhook 只能拦截处理 CRD 对象。</a></li><li><a href=#7operator-模式中webhook-组件和-controller-组件都是必须的>7.operator 模式中，webhook 组件和 controller 组件都是必须的。</a></li><li><a href=#8controller-的入队逻辑只取决于-crd-的状态变化>8.controller 的入队逻辑只取决于 CRD 的状态变化。</a></li><li><a href=#9-下列哪些设计是不可取的>9. 下列哪些设计是不可取的</a></li><li><a href=#10-下面哪种失败会导致-pod-创建失败>10. 下面哪种失败会导致 pod 创建失败</a></li></ul></li><li><a href=#第-25-讲kubernetes-网络模型进阶>第 25 讲：Kubernetes 网络模型进阶</a><ul><li><a href=#1flannel-hostgw-方案精髓是选以下哪个网卡上的-ip做非本地节点网段的-gw>1.Flannel-HostGW 方案精髓，是选以下哪个网卡上的 IP，做非本地节点网段的 GW</a></li><li><a href=#2-不通过-nodeport-接口外部无法调用-kubernetes-的-service>2. 不通过 Nodeport 接口，外部无法调用 Kubernetes 的 Service。</a></li><li><a href=#3-容器里面必须有网络设备才能叫容器网络>3. 容器里面必须有网络设备才能叫容器网络。</a></li><li><a href=#4-常见的网络五元组元素包含-4-层协议类型号>4. 常见的网络五元组元素包含 4 层协议类型号。</a></li><li><a href=#5ingress-机制就是来替换-service-的>5.Ingress 机制就是来替换 Service 的。</a></li><li><a href=#6pod-能且只能支持网络空间共享>6.Pod 能且只能支持网络空间共享。</a></li><li><a href=#7iptables-类型的-network-policy-可以通杀一切带-bridge-的容器网络数据方案>7.Iptables 类型的 network policy 可以通杀一切带 Bridge 的容器网络数据方案。</a></li><li><a href=#8underlay-方案全面优于-overlay-方案可以完全替代>8.Underlay 方案全面优于 Overlay 方案，可以完全替代。</a></li><li><a href=#9-有了-service云厂商的负载均衡服务不再有用武之地>9. 有了 Service，云厂商的负载均衡服务不再有用武之地。</a></li><li><a href=#10docker-的桥接网络优势是什么>10.Docker 的桥接网络优势是什么</a></li></ul></li><li><a href=#第-26-讲理解-cni-和-cni-插件>第 26 讲：理解 CNI 和 CNI 插件</a><ul><li><a href=#1kubernetes-的网络插件接口是什么>1.Kubernetes 的网络插件接口是什么</a></li><li><a href=#2-以下哪个不是路由模式的-cni-插件>2. 以下哪个不是路由模式的 CNI 插件</a></li><li><a href=#3-在虚拟化的环境中一般选择哪种类型的网络插件>3. 在虚拟化的环境中一般选择哪种类型的网络插件</a></li><li><a href=#4kubernetes-通过-grpc-接口调用网络插件>4.Kubernetes 通过 GRPC 接口调用网络插件。</a></li><li><a href=#5overlay-模式实现的网络插件性能损失较大>5.Overlay 模式实现的网络插件性能损失较大。</a></li><li><a href=#6overlay-模式对底层网络环境要求小>6.Overlay 模式对底层网络环境要求小。</a></li><li><a href=#7cni-插件一般由-daemon-和-binary-两部分组成>7.CNI 插件一般由 Daemon 和 Binary 两部分组成。</a></li><li><a href=#8cni-插件要负责的事情包括>8.CNI 插件要负责的事情包括</a></li><li><a href=#9-以下哪个是-underlay-网络模式的特点>9. 以下哪个是 Underlay 网络模式的特点</a></li><li><a href=#10-下列哪些可以作为打通-node-间网络通道的手段>10. 下列哪些可以作为打通 Node 间网络通道的手段</a></li></ul></li><li><a href=#第-27-讲kubernetes-安全之访问控制>第 27 讲：Kubernetes 安全之访问控制</a><ul><li><a href=#1-下列哪个选项不属于-kubernetes-api-请求流程>1. 下列哪个选项不属于 Kubernetes API 请求流程</a></li><li><a href=#2-在-x509-证书认证中下列哪个字段会被-apiserver-作为用户模型中的用户-user>2. 在 x509 证书认证中，下列哪个字段会被 apiserver 作为用户模型中的用户 (user)</a></li><li><a href=#3-以下哪种说法是错误的>3. 以下哪种说法是错误的</a></li><li><a href=#4-如果我们没有设置-kubeconfig-变量kubectl-客户端还会尝试从下列哪个路径读取-kubeconfig-配置>4. 如果我们没有设置 KUBECONFIG 变量，kubectl 客户端还会尝试从下列哪个路径读取 kubeconfig 配置</a></li><li><a href=#5-下列哪种认证方式是安全上不推荐的方式>5. 下列哪种认证方式是安全上不推荐的方式</a></li><li><a href=#6-下列哪个组件配置参数用于调整-kubernetes-中-certificatesigningrequest-实例签发证书的过期时间>6. 下列哪个组件配置参数用于调整 Kubernetes 中 CertificateSigningRequest 实例签发证书的过期时间</a></li><li><a href=#7rbac-中集群角色-clusterrole-可以绑定到-namespace-中的一个具体的-object-实例>7.RBAC 中集群角色 ClusterRole 可以绑定到 namespace 中的一个具体的 object 实例。</a></li><li><a href=#8-在一个-rolebinding-实例中一个绑定只能指定唯一的-role>8. 在一个 RoleBinding 实例中，一个绑定只能指定唯一的 Role。</a></li><li><a href=#9-下列关于-rbac-的说法哪些是正确的>9. 下列关于 RBAC 的说法，哪些是正确的</a></li><li><a href=#10-为了请求主体能够有权使用-kubectl-exec-it-pod-test-bash在主体绑定的角色模板中需要加入如下哪些策略>10. 为了请求主体能够有权使用 kubectl exec –it pod-test bash，在主体绑定的角色模板中需要加入如下哪些策略</a></li></ul></li><li><a href=#第-28-讲容器运行时接口-cri>第 28 讲：容器运行时接口 CRI</a><ul><li><a href=#1kubernetes-中crictl-是什么>1.Kubernetes 中，crictl 是什么</a></li><li><a href=#2kubernetes-的容器运行时接口英文简写是什么>2.Kubernetes 的容器运行时接口英文简写是什么</a></li><li><a href=#3kubernetes-中rkt-是什么>3.Kubernetes 中，rkt 是什么</a></li><li><a href=#4kubelet-与-cri-之间通过什么协议进行通信>4.Kubelet 与 CRI 之间通过什么协议进行通信</a></li><li><a href=#5cri-o-是哪个公司的开源产品>5.CRI-O 是哪个公司的开源产品</a></li><li><a href=#6-在-cri-的实现过程中需要进行-cni-操作>6. 在 CRI 的实现过程中，需要进行 CNI 操作。</a></li><li><a href=#7pausecontainer-是一个-cri-接口>7.PauseContainer 是一个 CRI 接口。</a></li><li><a href=#8grpc-协议的优点是>8.gRPC 协议的优点是</a></li><li><a href=#9cri-有哪几类接口>9.CRI 有哪几类接口</a></li><li><a href=#10-如何对-cri-进行拓展>10. 如何对 CRI 进行拓展</a></li></ul></li><li><a href=#第-29-讲安全容器运行时>第 29 讲：安全容器运行时</a><ul><li><a href=#1kata-containers-从哪个版本开始支持-shim-v2-的>1.Kata Containers 从哪个版本开始支持 shim-v2 的</a></li><li><a href=#2virtio-fs-应用了哪项技术可以跨沙箱共享只读内存>2.virtio-fs 应用了哪项技术可以跨沙箱共享只读内存</a></li><li><a href=#3kata-containers-项目是哪年宣布的>3.Kata Containers 项目是哪年宣布的</a></li><li><a href=#4gvisor-是用什么语言编写的>4.gVisor 是用什么语言编写的</a></li><li><a href=#5gvisor-把什么操作交给-gofer-进程来进行>5.gVisor 把什么操作交给 Gofer 进程来进行</a></li><li><a href=#6-在使用-kata-containers-的时候一个-pod-里面可以有几个容器>6. 在使用 Kata Containers 的时候，一个 Pod 里面可以有几个容器</a></li><li><a href=#7-安全容器和-runc-都可以运行-oci-image>7. 安全容器和 runC 都可以运行 OCI Image。</a></li><li><a href=#8-最早的容器技术-solaris-zone-在上个世纪的-1999-年就出现了>8. 最早的容器技术 Solaris Zone 在上个世纪的 1999 年就出现了。</a></li><li><a href=#9kata-containers-目前可以支持下列哪些虚拟机监视器vmm>9.Kata Containers 目前可以支持下列哪些虚拟机监视器（VMM）</a></li><li><a href=#10-下列哪种机制被-gvisor-用来拦截容器的-syscall>10. 下列哪种机制被 gVisor 用来拦截容器的 syscall</a></li></ul></li><li><a href=#第-30-讲理解-runtimeclass-与使用多容器运行时>第 30 讲：理解 RuntimeClass 与使用多容器运行时</a><ul><li><a href=#1-以下哪段配置表示-containerd-的默认容器运行时>1. 以下哪段配置表示 containerd 的默认容器运行时</a></li><li><a href=#2kubernetes-哪个版本引入了-runtimeclass>2.Kubernetes 哪个版本引入了 RuntimeClass</a></li><li><a href=#3-删除-runtimeclass-后对已有的-pod-overhead-有影响吗>3. 删除 RuntimeClass 后，对已有的 Pod Overhead 有影响吗</a></li><li><a href=#4-如果使用-runtimeclass-的-overhead需要开启哪个-admisson>4. 如果使用 RuntimeClass 的 Overhead，需要开启哪个 admisson</a></li><li><a href=#5pod-overhead-支持手动配置或更改>5.Pod Overhead 支持手动配置或更改。</a></li><li><a href=#6runtimeclass-是-cluster-级别的资源>6.RuntimeClass 是 cluster 级别的资源。</a></li><li><a href=#7-在没有配置-node-label-的情况下只要-pod-引用的-runtimeclass-配置了-schedulingpod-就一定会被调度到有对应容器运行时的节点上>7. 在没有配置 node label 的情况下，只要 Pod 引用的 RuntimeClass 配置了 Scheduling，Pod 就一定会被调度到有对应容器运行时的节点上。</a></li><li><a href=#8-哪些容器运行时是基于-cri-实现的>8. 哪些容器运行时是基于 CRI 实现的</a></li><li><a href=#9pod-overhead-会影响哪些功能>9.Pod Overhead 会影响哪些功能</a></li><li><a href=#10-以下哪些是-kubernetes-v116-版本新增特性>10. 以下哪些是 Kubernetes v1.16 版本新增特性</a></li></ul></li></ul></li></ul></nav></div></div><div class=content id=content><p><a href=https://edu.aliyun.com/roadmap/cloudnative>https://edu.aliyun.com/roadmap/cloudnative</a></p><h3 id=第-1-讲第一堂-云原生-课>第 1 讲：第一堂 “云原生” 课</h3><h4 id=3-单选-我编写的容器化应用会将日志文件写在某路径写死的目录里请问这破坏了云原生理念了吗>3. (单选) 我编写的容器化应用，会将日志文件写在某路径写死的目录里。请问这破坏了云原生理念了吗</h4><p>正确答案： B. 是</p><h3 id=第-2-讲容器基本概念>第 2 讲：容器基本概念</h3><h4 id=5-已运行-docker-run--d--t-name-demo-ubuntu-top-命令-是否可以在-demo-这个容器内部停止容器>5. 已运行 docker run -d -t —name demo ubuntu top 命令, 是否可以在 demo 这个容器内部停止容器</h4><ul><li>A. 是</li><li>B. 否</li></ul><p>正确答案： B</p><h4 id=8-已运行-docker-run--d--t-name-demo-ubuntu-top-和-docker-run---name-demo-x---pid-containerdemo-ubuntu-ps-命令是否可以在-demo-x-容器内部停止容器>8. 已运行 docker run -d -t —name demo ubuntu top 和 docker run &ndash;name demo-x &ndash;pid container:demo ubuntu ps 命令，是否可以在 demo-x 容器内部停止容器</h4><ul><li>A. 是</li><li>B. 否
正确答案： A</li></ul><h3 id=第-3-讲kubernetes-核心概念>第 3 讲：Kubernetes 核心概念</h3><h4 id=3-scheduler-的主要功能是________>3. Scheduler 的主要功能是________</h4><ul><li>A. Pod 的在 Node 上的放置</li><li>B. Pod 的生命周期管理</li><li>C. Node 上具体的资源分配</li><li>D. Node 的生命周期管理</li></ul><p>正确答案： A</p><h4 id=10-属于-node-上的基本组件有________>10. 属于 Node 上的基本组件有________</h4><ul><li>A. Kubelet</li><li>B. Kube-proxy</li><li>C. Controller Manager</li><li>D. Container runtime engine</li></ul><p>正确答案： A B D</p><h3 id=第-4-讲理解-pod-和容器设计模式>第 4 讲：理解 Pod 和容器设计模式</h3><h4 id=3-一个-pod-里-infra-container-的启动顺序是>3. 一个 Pod 里 Infra Container 的启动顺序是</h4><ul><li>A. 无所谓</li><li>B. 最后一个</li><li>C. 先于主业务容器启动即可</li><li>D. 第一个</li></ul><p>正确答案： D</p><h4 id=8-如果没有-pod-概念但我要用多个容器模拟-pod-的话可能需要做哪些工作>8. 如果没有 Pod 概念，但我要用多个容器模拟 Pod 的话，可能需要做哪些工作</h4><ul><li>A. resource hoarding</li><li>B. 乐观调度</li><li>C. 共享这些容器的 Network Namespace</li><li>D. 设置 Affinity 约束</li></ul><p>正确答案： A B C D</p><h4 id=9-关于-google-borg-论文论述正确的是>9. 关于 Google Borg 论文论述正确的是</h4><ul><li>A. 应用互相之间往往相互独立，毫不相关</li><li>B. 应用互相之间往往存在协作关系</li><li>C. 很多应用需要部署永远部署在同一台机器上</li><li>D. Google 在进行应用开发的过程中，天生就具备微服务的概念</li></ul><p>正确答案： B C D</p><h3 id=第-5-讲应用编排与管理---核心原理>第 5 讲：应用编排与管理 - 核心原理</h3><h4 id=1-controller-中的-workerqueue-中可以存放什么内容>1. Controller 中的 workerqueue 中可以存放什么内容</h4><ul><li>A. Namespace 名 + pod 名</li><li>B. Namespace 名 + pod 名 + 事件的类型</li><li>C. Pod 的列表</li><li>D. Pod 对象的指针</li></ul><p>正确答案： A</p><h4 id=2-controller-中的-object-store-默认以什么作为索引>2. Controller 中的 object store 默认以什么作为索引</h4><ul><li>A. 对象的 label</li><li>B. 对象的 annotation</li><li>C. 对象的 namespace</li><li>D. 对象的名字</li></ul><p>正确答案： C</p><h4 id=7-在-controller-的-event-handler-中-不适合执行的操作是>7. 在 controller 的 event handler 中， 不适合执行的操作是</h4><ul><li>A. 根据资源的 ownerreference 找到资源的创建者</li><li>B. 判断资源信息，对于不关心的对象， 直接返回</li><li>C. 在 workqueue 中加入资源</li><li>D. 执行控制器的实际处理工作</li></ul><p>正确答案： D</p><h4 id=8-下列关于-controller-中-workqueue-描述不正确的>8. 下列关于 controller 中 workqueue 描述不正确的</h4><ul><li>A. 因为 workqueue 具备去重功能，可以往 workqueue 中反复加入资源</li><li>B. 为了加速 controller 的处理，可以往 workqueue 中加入资源的指针</li><li>C. 一个控制器的 workqueue 一般只存储一种类型资源的名字</li><li>D. 对于处理 node 的控制器，可以只在 workqueue 中加入节点的名字而不包括命名空间</li></ul><p>正确答案： B</p><h4 id=10-以下不是声明式的-api-设计>10. 以下不是声明式的 API 设计</h4><ul><li>A. 创建一个容器的 API 是 POST /containers/create，请求参数是容器的各种规格， 返回系统生成的容器 id</li><li>B. 删除一个容器的 API 是 DELETE /containers/<containerid>, 返回一个异步删除的工单号，可以根据工单号查询删除进度</li><li>C. 给应用扩容的 API 是 PUT /containers/create?increaseReplicas=1， 参数指定扩容的增量容器数量</li><li>D. 更新一个容器镜像的 API 是 PATCH /containers/<containerid>?image=nginx, 返回的是容器新的目标状态</li></ul><p>正确答案： A B C</p><h3 id=第-6-讲应用编排与管理---deployment>第 6 讲：应用编排与管理 - Deployment</h3><h4 id=2-关于-maxunavailable-以下说法正确的是>2. 关于 MaxUnavailable 以下说法正确的是：</h4><ul><li>A. MaxUnavailable 不可以设置为 0，否则无法发布</li><li>B. MaxUnavailable 可以设置超过 replicas</li><li>C. MaxUnavailable 可以和 MaxSurge 同时设置为 0</li><li>D. MaxUnavailable 可以设置超过 100%</li></ul><p>正确答案： B</p><h4 id=8-deployment-与-replicaset-的关系与以下哪组资源最像>8. Deployment 与 ReplicaSet 的关系与以下哪组资源最像</h4><ul><li>A. Pod 与 Node</li><li>B. Pod 与 Container</li><li>C. ReplicaSet 与 Pod</li><li>D. Deployment 与 Pod</li></ul><p>正确答案： C</p><h4 id=9-以下关于-deployment-的说法正确的有哪些>9. 以下关于 Deployment 的说法正确的有哪些</h4><ul><li>A. Deployment 下 running 的 Pod 数量可能大于 replicas 数量</li><li>B. Deployment 更新镜像时一定会创建一个 ReplicaSet</li><li>C. 用 kubectl rollout undo 命令回滚 Deployment，不会创建新的 ReplicaSet</li><li>D. 滚动发布的时候 MaxUnavailable 和 MaxSurge 可以同时设为 0</li></ul><p>正确答案： A C</p><h4 id=10-指定-deployment-回滚到某个历史版本执行成功的过程中不会发生以下哪些事件>10. 指定 Deployment 回滚到某个历史版本执行成功的过程中，不会发生以下哪些事件：</h4><ul><li>A. Pod 创建和销毁</li><li>B. ReplicaSet 创建和销毁</li><li>C. Deployment 期望数量变化</li><li>D. Deployment template 变化</li></ul><p>正确答案： B C</p><h3 id=第-7-讲应用编排与管理---job-和-daemonset>第 7 讲：应用编排与管理 - Job 和 DaemonSet</h3><h4 id=9-使用哪些标签能让-daemonset-的-pod-只运行在某些节点>9. 使用哪些标签能让 daemonset 的 pod 只运行在某些节点</h4><ul><li>A. .spec.template.spec.nodeSelector</li><li>B. .spec.template.spec.affinity</li><li>C. Taints and Tolerations</li><li>D. matchExpressions</li></ul><p>正确答案： A B</p><blockquote><p>A Pod Template in a DaemonSet must have a RestartPolicy equal to Always, or be unspecified, which defaults to Always.</p></blockquote><h3 id=第-8-讲应用配置管理>第 8 讲：应用配置管理</h3><h4 id=6-当节点磁盘空间不足时pod-被驱逐的顺序为-besteffort-先于-burstable>6. 当节点磁盘空间不足时，Pod 被驱逐的顺序为: BestEffort 先于 Burstable</h4><p>正确答案： 正确</p><h4 id=10-如下哪些方式创建的-pod-可以使用-configmap>10. 如下哪些方式创建的 Pod 可以使用 ConfigMap</h4><ul><li>A. Kubectl</li><li>B. Dashboard</li><li>C. kubelet mainifests</li><li>D. kubelet url</li></ul><p>正确答案： A B</p><p>ConfigMap 使用注意点</p><ol><li>ConfigMap 文件大小限制：1MB（etcd 的要求）</li><li>Pod 只能引用相同 Namespace 中的 ConfigMap
3．Pod 引用的 ConfigMap 不存在时，Pod 无法创建成功。即 Pod 创建前需要先创建好 ConfigMap</li><li>使用 envFrom 从 ConfigMap 来配置环境变量时，如果 ConfigMap 中的某些 key 被认为无效（比如 key 名称中带有数字），该环境变量将不会注入容器，但是 Pod 可以正常创建。</li><li>只有通过 k8s api 创建的 pod 才能使用 ConfigMap, 其他方式创建的 pod（如 manifest 创建的 pod) 不能使用 ConfigMap</li></ol><h3 id=第-9-讲应用存储和持久化数据卷---核心知识>第 9 讲：应用存储和持久化数据卷 - 核心知识</h3><h4 id=5-在-pod-中声明使用-volume-需要配置哪些字段>5. 在 Pod 中声明使用 volume 需要配置哪些字段</h4><ul><li>A. .spec.volumes</li><li>B. .spec.initContainers.volumeMounts</li><li>C. .spec.containers.volumeMounts</li></ul><p>正确答案： A B C</p><h4 id=6-在-pod-中声明使用-volume-常见类型>6. 在 Pod 中声明使用 volume 常见类型</h4><ul><li>A. 本地存储</li><li>B. 网络存储</li><li>C. Projected Volume(投射卷)</li><li>D. PVC+PV 持久化存储</li></ul><p>正确答案： A B C D</p><h3 id=第-10-讲应用存储和持久化数据卷---存储快照与拓扑调度>第 10 讲：应用存储和持久化数据卷 - 存储快照与拓扑调度</h3><h4 id=3-下面在-kube-scheduler-中结合-pod-中声明的-pvcs-选择-node-过程描述正确的有>3. 下面在 Kube-Scheduler 中结合 Pod 中声明的 PVCs 选择 Node 过程描述正确的有</h4><ul><li>A. Pod 中已经 Bound 的 PVCs 在 Kube-Scheduler 不做处理</li><li>B. Pod 中所有 UnBound 的 PVCs 会先找到能匹配的 PV 列表，并 check PV 的 NodeAffinity 与 Node Labals 中的拓扑信息是否匹配</li><li>C. Pod 中需要 Dynamic Provisioning PV 的 PVCs，check StorageClass .allowedTopologies 与 Node Labels 中的拓扑信息是否匹配</li></ul><p>正确答案： C</p><h4 id=4-kubernetes-中为了支持存储拓扑调度相关组件做的改变有>4. Kubernetes 中为了支持存储拓扑调度相关组件做的改变有</h4><ul><li>A. PersistentVolumeController 支持 PVC 与 PV 的 delay binding</li><li>B. 动态创建 PV 的 csi-provisioner 支持将第一个使用 PV 的 Pod 待运行 Node 的拓扑信息以及 StorageClass .allowedTopologies 传递给创建存储的 Driver</li><li>C. Kube-Scheduler 结合 Pod 使用的 PVCs，预分配的 PV Node Affinity 以及 StorageClass .allowedTopologies 选择合适的 Node</li></ul><p>正确答案： A B C</p><h4 id=5-下列有关使用存储拓扑调度时对-storageclass-的配置正确的有>5. 下列有关使用存储拓扑调度时对 StorageClass 的配置正确的有</h4><ul><li>A. 需要通过设置. volumeBindingMode: WaitForFirstConsumer 来声明 PVC 延时处理</li><li>B. 可以通过. allowedTopologies 限制动态生成的 PV 的拓扑限制，拓扑限制会写到动态生成的 PV .spec.nodeAffinity 中</li><li>C. 可以干预哪些需要使用该 StorageClass 动态生成 PV 对象的 PVC 的使用方 Pod 的可调度的 Node</li></ul><p>正确答案： A B C</p><h4 id=7-可以限制-pv-对象可被访问拓扑位置限制的地方>7. 可以限制 PV 对象可被访问拓扑位置限制的地方</h4><ul><li>A. StorageClass: .allowedTopologies</li><li>B. PV: .spec.nodeAffinity</li><li>C. Node: .metadata.labels</li></ul><p>正确答案： A B</p><h4 id=8-下列有关如何使用存储拓扑调度的说法正确的有>8. 下列有关如何使用存储拓扑调度的说法正确的有</h4><ul><li>A. 声明 delay binding 的 StorageClass 对象（.volumeBindingMode=WaitForFirstConsumer）</li><li>B. PVC 对象. spec.storageClassName 指定为声明了 delay binding 的 StorageClass 对象</li><li>C. 在静态（预）创建的 PV 上的. spec.nodeAffinity 添加对使用该 PV 的 Pod 所在 Node 拓扑限制</li><li>D. 在需要动态创建的 PV 所使用的 StorageClass 的. allowedTopologies 中限制动态创建的存储能被使用的拓扑限制</li></ul><p>正确答案： A B C D</p><h4 id=9-使用存储快照功能需要用到哪些-kubernetes-api-资源对象>9. 使用存储快照功能需要用到哪些 Kubernetes API 资源对象</h4><ul><li>A. VolumeSnapshot</li><li>B. VolumeSnapshotClass</li><li>C. VolumeSnapshotContent</li><li>D. PersistentVolumeClaim</li></ul><p>正确答案： A B C D</p><h3 id=第-11-讲可观测性你的应用健康吗>第 11 讲：可观测性——你的应用健康吗</h3><h4 id=4-readiness-probe-可以解决应用启动慢造成访问异常的问题>4. Readiness Probe 可以解决应用启动慢造成访问异常的问题。</h4><p>正确</p><p>错误</p><p>正确答案： 正确</p><h4 id=7-当-pod-处在-pending-的时候可能是由于如下哪个问题造成的>7. 当 Pod 处在 Pending 的时候，可能是由于如下哪个问题造成的。</h4><ul><li>A. 资源不足，造成无法调度</li><li>B. Pod 尚未进入调度阶段</li><li>C. Pod 调度失败</li><li>D. Pod 正在拉取镜像</li></ul><p>正确答案： A B D</p><h4 id=9-以下哪个关于-liveness-probe-的描述是错误的>9. 以下哪个关于 Liveness Probe 的描述是错误的</h4><ul><li>A. Liveness Probe 是就绪探针</li><li>B. Liveness Probe 是存活探针</li><li>C. Livenss Probe 和 Readiness Probe 的探测方式是一致的</li><li>D. Liveness Probe 主要面向有状态服务</li></ul><p>正确答案： A D</p><h3 id=第-12-讲可观测性监控与日志>第 12 讲：可观测性——监控与日志</h3><h4 id=2-以下哪个不是-prometheus-的优势>2. 以下哪个不是 Prometheus 的优势</h4><ul><li>A. Prometheus 的采集性能优越</li><li>B. Prometheus 的采集方式丰富</li><li>C. Prometheus 的接入方式简单</li><li>D. Prometheus 的插件丰富</li></ul><p>正确答案： A</p><h3 id=第-13-讲kubernetes-网络概念及策略控制>第 13 讲：Kubernetes 网络概念及策略控制</h3><h4 id=1-影响容器网络性能最关键的因素是哪个>1. 影响容器网络性能最关键的因素是哪个</h4><ul><li>A. IP 地址管理方式</li><li>B. 是否使用隧道技术</li><li>C. 网络拓扑路径</li><li>D. 底层网络性能</li></ul><p>正确答案： C</p><h4 id=3-哪种容器网络方案是普适性最高的默认选择>3. 哪种容器网络方案是普适性最高的默认选择</h4><ul><li>A. Flannel-vxLan</li><li>B. Flannel-host gw</li><li>C. Canal</li><li>D. Calico</li></ul><p>正确答案： A</p><h4 id=5-net-namespace-拥有完全独立隔离的网络环境>5. net namespace 拥有完全独立隔离的网络环境。</h4><p>正确</p><p>错误</p><p>正确答案： 错误</p><p>相关知识点： 不准确，协议栈代码是公用的，很多 systemctl 可控参数并没有独立</p><h4 id=6-kubernetes-的-pod-只能有且只能配置-1-个-ip-地址>6. Kubernetes 的 Pod 只能有且只能配置 1 个 IP 地址。</h4><p>正确</p><p>错误</p><p>正确答案： 错误</p><p>相关知识点： 不准确，可以有多个 IP 地址，只是上报给 CNI 结果时候，只能报一个</p><h4 id=7-kubernetes-network-policy-只支持-tcpudp-作为协议字段值>7. Kubernetes network policy 只支持 TCP/UDP 作为协议字段值。</h4><p>正确</p><p>错误</p><p>相关知识点： 还支持 stcp（alpha 特性）</p><p>正确答案： 错误</p><h4 id=8-kubernetes-容器网络方案实现上禁止任何形式的地址转换nat>8. Kubernetes 容器网络方案实现上，禁止任何形式的地址转换（NAT）。</h4><p>正确</p><p>错误</p><p>相关知识点： 可以使用 NAT 作为实现手段，不能被 Pod-APP 感知</p><h4 id=9-kubernetes-基本网络模型需要符合哪些条件>9. Kubernetes 基本网络模型需要符合哪些条件</h4><ul><li>A. 所有 Pod 可以与其他 Pod 直接通信，无需显式使用 NAT</li><li>B. 所有 Node 可以与所有 Pod 直接通信，无需显式使用 NAT</li><li>C. Pod 可见的 IP 地址确为其他 Pod 与其通信时所用，无需显式转换</li></ul><p>正确答案： A B C</p><h4 id=10-kubernetes-网络方案需要考虑哪些需要达成的连通性目标>10. Kubernetes 网络方案需要考虑哪些需要达成的连通性目标</h4><ul><li>A. 容器与容器间的通信</li><li>B. Pod 与 Pod 之间的通信</li><li>C. Pod 与 Service 间的通信</li><li>D. 外部世界与 Service 间的通信</li></ul><p>正确答案： A B C D</p><h3 id=第-14-讲kubernetes-services>第 14 讲：Kubernetes Services</h3><h4 id=5-创建-loadbalancer-类型的-service-会自动创建和绑定外部-loadbalancer-到节点映射的-nodeport-上>5. 创建 LoadBalancer 类型的 Service 会自动创建和绑定外部 LoadBalancer 到节点映射的 NodePort 上。</h4><p>正确</p><p>错误</p><p>正确答案： 正确</p><h4 id=8-pod-可以直接用-service-名来访问同一个集群里的-service不管-pod-和-service-在不在一个-namespace>8. Pod 可以直接用 Service 名来访问同一个集群里的 Service，不管 Pod 和 Service 在不在一个 Namespace。</h4><p>正确</p><p>错误</p><p>正确答案： 错误</p><h3 id=第-15-讲深入剖析-linux-容器>第 15 讲：深入剖析 Linux 容器</h3><h4 id=3-docker-在宿主机上最多可以创建多少个容器>3. docker 在宿主机上最多可以创建多少个容器</h4><ul><li>A. 1000</li><li>B. 和宿主机的 cpu/memory 资源有关系</li><li>C. 不一定</li></ul><p>正确答案： C</p><h4 id=4-宿主机上能否看见容器内的进程>4. 宿主机上能否看见容器内的进程</h4><ul><li>A. 不能，因为容器有自己的 pid namespace，隔离了宿主机上的进程可见性</li><li>B. 能，只是容器内外看到的进程 pid 不一样</li></ul><p>正确答案： B</p><h4 id=7-运行-docker-stop-container-命令停止一个容器后容器的相关文件还在吗>7. 运行 docker stop $container 命令停止一个容器后，容器的相关文件还在吗</h4><ul><li>A. 在，stop 只是停止了进程，文件等内容还是在宿主机上的</li><li>B. 不在，进程消失了，容器全部都不见了</li></ul><p>正确答案： A</p><h4 id=8-已运行-docker-run--d--t---name-demo-ubuntu-top-和-docker-run---name-demo-x---pid-containerdemo-ubuntu-ps-命令是否可以在-demo-x-容器内停止容器>8. 已运行 docker run -d -t &ndash;name demo ubuntu top 和 docker run &ndash;name demo-x &ndash;pid container:demo ubuntu ps 命令，是否可以在 demo-x 容器内停止容器</h4><p>正确</p><p>错误</p><p>正确答案： 正确</p><h4 id=9-已运行-docker-run--d--t---name-demo-ubuntu-top-命令-是否在-demo-这个容器内部停止容器>9. 已运行 docker run -d -t &ndash;name demo ubuntu top 命令, 是否在 demo 这个容器内部停止容器</h4><p>正确</p><p>错误</p><p>正确答案： 错误</p><h4 id=10-已运行-docker-run--d--t---name-demo-ubuntu-top-和-docker-run---name-demo-x---pid-containerdemo-ubuntu-ps-命令如果-demo-容器退出了正在运行的-demo-x-容器是否会退出>10. 已运行 docker run -d -t &ndash;name demo ubuntu top 和 docker run &ndash;name demo-x &ndash;pid container:demo ubuntu ps 命令，如果 demo 容器退出了，正在运行的 demo-x 容器是否会退出</h4><p>正确</p><p>错误</p><p>正确答案：正确</p><h3 id=理解-etcd-的核心设计思想>理解 etcd 的核心设计思想</h3><h4 id=6-etcd-集群中存在-3-个-server-时重启其中一个-server-完全不会影响服务>6. etcd 集群中存在 3 个 server 时，重启其中一个 server 完全不会影响服务。</h4><p>正确</p><p>错误</p><p>正确答案： 错误</p><h4 id=9-关于-etcd-lease以下说法正确的是>9. 关于 etcd lease，以下说法正确的是</h4><ul><li>A. etcd 创建 lease 对象时，需要指定一个时间作为其超时时间。</li><li>B. lease 对象被创建后，超过设定的时间一定会被系统自动回收。</li><li>C. 将 key 关联到 lease 对象上，当 lease 对象超时后，key 会被系统自动回收。</li><li>D. etcd 支持将多个 key 关联到同一个 lease 对象上，从而大幅降低刷新 lease 的性能开销。</li></ul><p>正确答案： A C D</p><h3 id=第-17-讲深入理解-etcd---etcd-性能优化实践>第 17 讲：深入理解 etcd - etcd 性能优化实践</h3><h4 id=5-etcd-满足了-cap-原理中的哪些特性>5. etcd 满足了 CAP 原理中的哪些特性</h4><ul><li>A. CA</li><li>B. CP</li><li>C. AP</li><li>D. CAP</li></ul><p>正确答案： B</p><h4 id=8-以下说法正确的是>8. 以下说法正确的是</h4><ul><li>A. 新的 etcd 采用了 segregated hashmap 算法管理 freelist</li><li>B. freelist 是内部已存储数据页面的集合</li><li>C. 采用新的页面管理算法后，etcd 存储数据量大幅度提升</li><li>D. compact 删除历史数据不会影响 etcd 性能</li></ul><p>正确答案： A C</p><p>freelist 是内部存储被释放的数据页面的集合</p><h4 id=10-关于-etcd-lease以下说法正确的是>10. 关于 etcd lease，以下说法正确的是</h4><ul><li>A. 新版本的 etcd 对 lease 处理进行了优化</li><li>B. etcd 中可以存有大量的 lease</li><li>C. etcd 切换 leader 后，lease 会丢失</li><li>D. etcd 切换 leader 后，原有 lease ttl 信息会不准</li></ul><p>正确答案： A D</p><p><a href=https://github.com/etcd-io/etcd/issues/9395>https://github.com/etcd-io/etcd/issues/9395</a></p><blockquote><p>It is needed since only the leader records TTL for performance reasons. It wont be changed.
We should document it though. But if you expect the leader changes much more frequent than lease can expire, you have to either make your cluster more reliable or shorter the lease.</p></blockquote><h3 id=第-18-讲kubernetes-调度和资源管理>第 18 讲：Kubernetes 调度和资源管理</h3><h4 id=1-挑选一个合适节点作为抢占节点的策略当中哪个因素是排在第一位的考虑因素>1. 挑选一个合适节点作为抢占节点的策略当中，哪个因素是排在第一位的考虑因素</h4><ul><li>A. 破环 PDB 最少的节点</li><li>B. Pods 优先级加和最小的节点</li><li>C. Pods 数目最少的节点</li><li>D. 最近启动 Pod 的节点</li></ul><p>正确答案: A</p><h4 id=7-在资源列表中-15gi-内存也可以用以下哪个方式表达>7. 在资源列表中 1.5Gi 内存也可以用以下哪个方式表达</h4><ul><li>A. 1500m</li><li>B. 1500Mi</li><li>C. 1536m</li><li>D. 1536Mi</li></ul><p>正确答案： D</p><h4 id=10-下列哪种-requestlimit-使用方式代表创建-burstable-的-pod>10. 下列哪种 request/limit 使用方式代表创建 Burstable 的 Pod</h4><ul><li>A. CPU/Memery 都填了，但 request&lt;limit</li><li>B. 只填了 CPU 资源的 request，Memory 资源 request 和 limit 都没填</li><li>C. CPU 和 Memory 资源都没填，但填了 GPU 的 request</li><li>D. 只填了 CPU/Memory，且 request=limit</li></ul><p>正确答案： A B C</p><h3 id=第-19-讲调度器的调度流程和算法介绍>第 19 讲：调度器的调度流程和算法介绍</h3><h4 id=1-下列关于打分器prioritize的作用描述不正确的是>1. 下列关于打分器（prioritize）的作用描述不正确的是</h4><ul><li>A. 能用来确保 Pod 之间的亲和部署</li><li>B. 用来尽量满足 Pod 和 Node 亲和部署</li><li>C. 支持 Pod 在节点上尽量打散</li><li>D. 可以用来支持 Pod 尽量调度到已有此镜像的节点</li></ul><p>正确答案： A</p><h4 id=4-以下扩展点哪个是-scheduler-extender-不支持的>4. 以下扩展点哪个是 scheduler extender 不支持的</h4><ul><li>A. filter</li><li>B. prioritize</li><li>C. bind</li><li>D. prebind</li></ul><p>正确答案： D</p><h4 id=6-调度节点选择的逻辑是>6. 调度节点选择的逻辑是</h4><ul><li>A. 随机选择节点用于过滤</li><li>B. 优先把一个 Zone 的节点过滤完之后，再选择下一个 Zone</li><li>C. 选择节点按照 Zone 分组进行 RoundRobine 选择，使得取样模板在 zone 上更均衡</li></ul><p>正确答案： C</p><h3 id=第-20-讲gpu-管理和-device-plugin-工作机制>第 20 讲：GPU 管理和 Device Plugin 工作机制</h3><h4 id=1device-plugin-的-allocateresponse-中可以接收如下哪些参数>1.Device Plugin 的 AllocateResponse 中可以接收如下哪些参数</h4><ul><li>A. devices</li><li>B. mounts</li><li>C. envs</li><li>D. cpus</li></ul><p>正确答案： A B C(试卷说是单选, 题目有问题)</p><h4 id=2device-plugin-中-api-可以用来反映设备健康状况的方法名称是>2.Device Plugin 中 API 可以用来反映设备健康状况的方法名称是</h4><ul><li>A. Allocate</li><li>B. Register</li><li>C. ListAndWatch</li><li>D. PreStartContainer</li></ul><p>正确答案： C</p><h4 id=3kubernetes-是从哪个版本开始支持-device-plugin>3.Kubernetes 是从哪个版本开始支持 Device Plugin</h4><ul><li>A. 1.8</li><li>B. 1.9</li><li>C. 1.10</li><li>D. 1.11</li></ul><p>正确答案： A</p><p><a href=https://github.com/kubernetes/kubernetes/blob/master/CHANGELOG/CHANGELOG-1.8.md#kubelet>https://github.com/kubernetes/kubernetes/blob/master/CHANGELOG/CHANGELOG-1.8.md#kubelet</a></p><h4 id=4-使用-kubernetes-管理-gpu-资源可以利用-kubernetes-的统一调度能力使资源使用方能够用即申请完即释放从而盘活整个-gpu-资源池>4. 使用 Kubernetes 管理 GPU 资源可以利用 Kubernetes 的统一调度能力，使资源使用方能够用即申请，完即释放，从而盘活整个 GPU 资源池。</h4><ul><li>正确</li><li>错误</li></ul><p>正确答案： 正确</p><h4 id=5-如果需要构建-gpu-容器镜像必须要在镜像里安装英伟达驱动cuda-库>5. 如果需要构建 GPU 容器镜像，必须要在镜像里安装英伟达驱动、CUDA 库。</h4><ul><li>正确</li><li>错误</li></ul><p>正确答案： 错误, 驱动由宿主机提供, 通过挂载给容器使用</p><h4 id=6-必须要使用-nvidia-docker-才能运行-gpu-容器>6. 必须要使用 Nvidia Docker 才能运行 GPU 容器。</h4><ul><li>正确</li><li>错误</li></ul><p>正确答案： 错误</p><h4 id=7-可以通过-nvidiacomgpu05-申请-gpu>7. 可以通过 nvidia.com/gpu=0.5 申请 GPU。</h4><ul><li>正确</li><li>错误</li></ul><p>正确答案： 错误</p><h4 id=8device-plugin-机制只能支持-nvidia-gpu而无法支持-amd-gpu>8.Device Plugin 机制只能支持 Nvidia GPU，而无法支持 AMD GPU。</h4><ul><li>正确</li><li>错误</li></ul><p>正确答案： 错误</p><h4 id=9-当前-kubernetes-先可以支持复杂场景的-gpu-调度比如-gpu-精细调度具体来说可以调度彼此间有-nvlink-连接的两个-gpu-卡>9. 当前 Kubernetes 先可以支持复杂场景的 GPU 调度，比如 GPU 精细调度，具体来说可以调度彼此间有 NVLink 连接的两个 GPU 卡。</h4><ul><li>正确</li><li>错误</li></ul><p>正确答案： 错误</p><h4 id=10kubernetes-通过哪些内部机制支持-gpu-管理>10.Kubernetes 通过哪些内部机制支持 GPU 管理</h4><ul><li>A. CNI Plugin</li><li>B. Device Plugin</li><li>C. Extended Plugin</li><li>D. Cloud Provider</li></ul><p>正确答案: B C</p><h3 id=第-21-讲kubernetes-存储架构及插件使用>第 21 讲：Kubernetes 存储架构及插件使用</h3><h4 id=1-下面哪个不是-csi-crd-定义的对象>1. 下面哪个不是 CSI CRD 定义的对象</h4><p>A. PVC</p><p>B. CSIDriver</p><p>C. CSINode</p><p>D. VolumeAttachment</p><p>正确答案: A</p><h4 id=2-关于-volume-的-provisionattachmount-操作下面说法错误的是>2. 关于 Volume 的 Provision、Attach、Mount 操作，下面说法错误的是</h4><ul><li>A. PV controller 只能负责 Provision 操作</li><li>B. AD Controller 只能负责 Attach 操作</li><li>C. Volume Manager 只能负责 Mount 操作</li></ul><p>正确答案: C</p><h4 id=3-关于存储卷回收策略下面说法错误的是>3. 关于存储卷回收策略，下面说法错误的是</h4><ul><li>A. Retain 模式：PVC 删除后，PV 依然存在</li><li>B. 动态生成的 PV，默认为 Retain 模式</li><li>C. Delete 模式：PVC 删除后，PV 同时被删除</li><li>D. Recycle 模式：PVC 删除后，PV 可再次使用</li></ul><p>正确答案: B</p><h4 id=4-关于-kubernetes-volumeplugin下面说法错误的是>4. 关于 Kubernetes VolumePlugin，下面说法错误的是</h4><ul><li>A. Volume Plugin 分为 In-Tree、Out-Of-Tree 两种类型</li><li>B. In-Tree 类型插件，和 Kubernetes 融合度高，是社区推荐的使用方式</li><li>C. Out-Of-Tree 类型插件，解耦了编排系统和存储服务，是社区推荐的使用方式</li><li>D. VolumePlugin 是 Kubernetes 对存储卷访问的接口抽象</li></ul><p>正确答案: B</p><h4 id=5-关于-flexvolume-接口下面说法正确的是>5. 关于 Flexvolume 接口，下面说法正确的是</h4><ul><li>A. Attach 接口一定会被调用</li><li>B. ExpandVolumeDevice 实现文件系统扩容</li><li>C. 所有接口都必须实现</li><li>D. MountDevice 接口实现设备挂载到 Global 目录</li></ul><p>正确答案： D</p><h4 id=6-关于-flexvolumecsi下面说法正确的有>6. 关于 Flexvolume、CSI，下面说法正确的有</h4><ul><li>A. 相比 Flexvolume，CSI 能提供更好的安全能力</li><li>B. Flexvolume 是非容器化部署，依赖难以解决</li><li>C. CSI、Flexvolume 都只能支持 Kubernetes 平台</li><li>D. CSI 通过容器化部署，是社区推荐的插件方案</li></ul><p>正确答案： A B D</p><h4 id=7-关于-flexvolume下面说法正确的有>7. 关于 Flexvolume，下面说法正确的有</h4><ul><li>A. Flexvolume 可以支持 Attach 操作</li><li>B. Flexvolume 是一个守护进程</li><li>C. Flexvolume 可以支持 Provision 操作</li><li>D. Flexvolume 是运行在主机空间的程序</li></ul><p>正确答案： A D</p><h4 id=8-关于-csi-组件下面说法正确的有>8. 关于 CSI 组件，下面说法正确的有</h4><ul><li>A. PV Controller 调用 External Provisioner 实现创建数据卷功能</li><li>B. 有些存储类型可以不部署 External Attacher</li><li>C. Kubelet 直接调用 CSI Plugin 实现数据卷的 Mount/Unmount 操作</li><li>D. CSI Controller Server 和 CSI Node Server 每个节点都需要部署</li></ul><p>正确答案： B C</p><h4 id=9-关于-pvpvc-绑定下面说法正确的有>9. 关于 pv、pvc 绑定，下面说法正确的有</h4><ul><li>A. 必须 Access Modes 相同的 pv、pvc 才可以绑定</li><li>B. PVC 定义的 Capacity 必须等于 PV 的 Capacity 才可以绑定</li><li>C. 可以通过 Selector 配置特定的 PVC、PV 绑定</li><li>D. PVC 找不到匹配的 PV 时，才会触发 Provisioner 创建 PV</li></ul><p>正确答案： C D</p><h4 id=10-关于-csi下面说法正确的有>10. 关于 CSI，下面说法正确的有</h4><ul><li>A. CSI 以容器方式部署</li><li>B. CSI-Provisioner 需要部署成 DaemonSet 模式</li><li>C. CSI Plugin 通过本地 Socket 与 kubelet 通信</li><li>D. CSI 只是针对 Kubernetes 设计的存储接口</li></ul><p>正确答案： A C</p><h3 id=第-22-讲有状态应用编排statefulset>第 22 讲：有状态应用编排：StatefulSet</h3><h4 id=1-通过-statefulset-不能实现以下哪个功能>1. 通过 StatefulSet 不能实现以下哪个功能</h4><ul><li>A. 应用扩缩容</li><li>B. 应用发布回滚</li><li>C. 应用重启</li><li>D. 应用副本数量维持</li></ul><p>正确答案： C</p><h4 id=2-创建-statefulset-spec-中的-template-字段用处不包括>2. 创建 StatefulSet spec 中的 template 字段，用处不包括</h4><ul><li>A. 声明 Pod 容器的挂载目录</li><li>B. 声明 Pod 需要的 pvc 模板</li><li>C. 指定镜像版本</li><li>D. 指定 Pod 容器重启策略</li></ul><p>正确答案： B</p><h4 id=3-以下哪个是-statefulset-中要填写-servicename-的根本原因>3. 以下哪个是 StatefulSet 中要填写 serviceName 的根本原因</h4><ul><li>A. 有状态应用必须配置 service</li><li>B. 通过 headless service 来为 StatefulSet 提供服务</li><li>C. 通过 headless service 来为 StatefulSet 的每个 Pod 提供唯一 hostname</li><li>D. 通过 headless service 来提高有状态服务的性能</li></ul><p>正确答案： C</p><h4 id=4-如果-statefulset-的-podmanagementpolicy-设置为-parallel则下列哪个说法错误>4. 如果 StatefulSet 的 podManagementPolicy 设置为 Parallel，则下列哪个说法错误</h4><ul><li>A. 不再严格按照顺序 Ready 的方式串行创建 Pod</li><li>B. 不再严格按照倒序串行缩容 Pod</li><li>C. 不再严格按照倒序串行升级 Pod</li><li>D. podManagementPolicy 是可选字段，yaml 中可以不填</li></ul><p>正确答案： C</p><h4 id=5-以下关于-controllerrevision-历史版本说法正确的是>5. 以下关于 ControllerRevision 历史版本说法正确的是</h4><ul><li>A. 所有历史版本都会作为 ControllerRevision 保留</li><li>B. pod label 中的 controller-revision-hash 与对应版本 ControllerRevision name 一致</li><li>C. revisionHistoryLimit 字段不设置默认没有数量限制</li><li>D. 更新了 StatefulSet spec 中字段，就会创建一个新的 ControllerRevision</li></ul><p>正确答案： B</p><h4 id=6-以下哪个不可能是名为-nginx-web-的-statefulset-扩容出来的-podpvc-name>6. 以下哪个不可能是名为 nginx-web 的 StatefulSet 扩容出来的 pod/pvc name</h4><ul><li>A. nginx-web-1</li><li>B. nginx-web-15</li><li>C. tmp-nginx-web-3</li><li>D. nginx-web-tmp-1</li></ul><p>正确答案： D</p><h4 id=7-通过配置-statefulset可以使每个-pod-对应一个独立的-pvc也可以使所有-pod-共用一个-pvc>7. 通过配置 StatefulSet，可以使每个 Pod 对应一个独立的 PVC，也可以使所有 Pod 共用一个 PVC。</h4><ul><li>正确</li><li>错误</li></ul><p>正确答案： 正确</p><h4 id=8-关于-statefulset-中的-volumeclaimtemplates下列说法错误的有哪些>8. 关于 StatefulSet 中的 volumeClaimTemplates，下列说法错误的有哪些</h4><ul><li>A. 创建出的 PVC name，就是 volumeClaimTemplates 中的 metadata.name 加一个 order 序号</li><li>B. 如果设置了 volumeClaimTemplates，那么每次创建 Pod 之前都会发生 PVC 创建</li><li>C. volumeClaimTemplates 里能设置多个 PVC 模板</li><li>D. 如果不设置 volumeClaimTemplates，那么 StatefulSet 创建出的 Pod 就无法使用 PVC</li></ul><p>正确答案： A B D</p><h4 id=9-以下关于-statefulset-和-deployment-的区别说法正确的有哪些>9. 以下关于 StatefulSet 和 Deployment 的区别说法正确的有哪些</h4><ul><li>A. StatefulSet 的 Pod 能使用 PVC，Deployment 的 Pod 不能</li><li>B. StatefulSet 有的发布能力，Deployment 都有</li><li>C. StatefulSet 发布前后 Pod name 不变，而 Deployment 会变</li><li>D. StatefulSet 直接操作管理 Pod 资源，而 Deployment 则不会</li></ul><p>正确答案： C D</p><h4 id=10-一个-replicas10partition8-的-statefulset在某一个时刻-status-可能处于以下哪些状态>10. 一个 replicas=10、partition=8 的 StatefulSet，在某一个时刻 status 可能处于以下哪些状态</h4><ul><li>A. currentReplicas:8 updatedReplicas: 2</li><li>B. currentReplicas:9 updatedReplicas: 1</li><li>C. currentReplicas:10 updatedReplicas: 10</li><li>D. currentReplicas:6 updatedReplicas: 2</li></ul><p>正确答案： A B C D</p><h3 id=第-23-讲kubernetes-api-编程范式>第 23 讲：Kubernetes API 编程范式</h3><h4 id=1kubernetes-crd-是在哪个版本被引入的>1.Kubernetes CRD 是在哪个版本被引入的</h4><ul><li>A. 1.6</li><li>B. 1.7</li><li>C. 1.8</li><li>D. 1.9</li></ul><p>正确答案： B</p><h4 id=2-自定义资源使用什么字段来嵌套其他子资源>2. 自定义资源使用什么字段来嵌套其他子资源</h4><ul><li>A. status</li><li>B. subresource</li><li>C. spec</li><li>D. metadata</li></ul><p>正确答案： B</p><h4 id=3-自定义资源能够具备自己的状态字段吗>3. 自定义资源能够具备自己的状态字段吗</h4><ul><li>A. 能</li><li>B. 不能</li></ul><p>正确答案： A</p><h4 id=4kubernetes-自定义资源一般指的是>4.Kubernetes 自定义资源一般指的是</h4><ul><li>A. CRD</li><li>B. 扩展 APIServer</li></ul><h4 id=5crd-必须配合-controller-才能有效果>5.CRD 必须配合 controller 才能有效果。</h4><ul><li>正确</li><li>错误</li></ul><p>正确答案： 正确</p><h4 id=6kubernetes-自定义资源出现的原因是什么>6.Kubernetes 自定义资源出现的原因是什么</h4><ul><li>A. 用户自定义资源需求比较多</li><li>B. Kubernetes 原生资源无法满足需求</li><li>C. Kubernetes APIServer 扩展比较复杂</li><li>D. 用户对 Kubernetes 架构不满意</li></ul><p>正确答案： A B C</p><h4 id=7kubernetes-crd-可以和内置资源共享什么资源>7.Kubernetes CRD 可以和内置资源共享什么资源</h4><ul><li>A. kubectl</li><li>B. RBAC</li><li>C. Deployment</li><li>D. Pod</li></ul><p>正确答案： A B</p><h4 id=8controller-通过-来同时处理多个对象的请求>8.Controller 通过（ ）来同时处理多个对象的请求</h4><ul><li>A. Queue</li><li>B. Worker</li><li>C. Handler</li><li>D. Manager</li></ul><p>正确答案： A B</p><h4 id=9-关于-controller-的描述以下正确的有>9. 关于 Controller 的描述，以下正确的有</h4><ul><li>A. Controller 是 Kubernetes 的大脑</li><li>B. Controller 来完成具体的 CRD 操作</li><li>C. Controller 完成全部的 CRD 功能</li><li>D. Controller 必须配合 CRD 才能完成功能</li></ul><p>正确答案： A B</p><h4 id=10controller-一般具备哪几个函数来接受请求>10.Controller 一般具备哪几个函数来接受请求</h4><ul><li>A. AddFunc</li><li>B. UpdateFunc</li><li>C. DeleteFunc</li><li>D. PopFunc</li></ul><p>正确答案： A B C</p><h3 id=第-24-讲kubernetes-api-编程利器operator-和-operator-framework>第 24 讲：Kubernetes API 编程利器：Operator 和 Operator Framework</h3><h4 id=1-在-webhook-业务逻辑中下列哪些行为是不建议的>1. 在 webhook 业务逻辑中，下列哪些行为是不建议的</h4><ul><li>A. 设置缺省值</li><li>B. 校验字段正确性</li><li>C. 调用外部 api</li><li>D. 处理非 CRD 对象</li></ul><p>正确答案： C</p><h4 id=2-在-controller-入队逻辑中下列哪些行为是不建议的>2. 在 controller 入队逻辑中，下列哪些行为是不建议的</h4><ul><li>A. 查询 CRD 对象</li><li>B. 查询 CRD 关联对象</li><li>C. 根据对象字段做入队过滤</li><li>D. 处理业务逻辑</li></ul><p>正确答案： D</p><h4 id=3-大多数情况下只能工作在主备模式的是>3. 大多数情况下只能工作在主备模式的是</h4><ul><li>A. apiserver</li><li>B. validating webhook</li><li>C. mutating webhook</li><li>D. controller</li></ul><p>正确答案： D</p><h4 id=4controller-入队逻辑针对可能丢失事件的正确处理方法是什么>4.controller 入队逻辑针对可能丢失事件的正确处理方法是什么</h4><ul><li>A. 无论什么事件都尽量入队</li><li>B. 给相关对象增加 finalizer</li><li>C. 定时轮询资源对象</li><li>D. 同一个事件入队多次</li></ul><p>正确答案： B</p><h4 id=5webhook-只能拦截处理-crd-对象>5.webhook 只能拦截处理 CRD 对象。</h4><ul><li>正确</li><li>错误</li></ul><p>正确答案： 错误</p><p>####　6.controller Reconcile 主循环返回错误会入队重试。</p><ul><li>正确</li><li>错误</li></ul><p>正确答案： 正确</p><h4 id=7operator-模式中webhook-组件和-controller-组件都是必须的>7.operator 模式中，webhook 组件和 controller 组件都是必须的。</h4><ul><li>正确</li><li>错误</li></ul><p>正确答案： 错误</p><h4 id=8controller-的入队逻辑只取决于-crd-的状态变化>8.controller 的入队逻辑只取决于 CRD 的状态变化。</h4><ul><li>正确</li><li>错误</li></ul><p>正确答案： 错误</p><h4 id=9-下列哪些设计是不可取的>9. 下列哪些设计是不可取的</h4><ul><li>A. controller 主循环函数不幂等</li><li>B. controller 实时更新 CRD status 信息</li><li>C. 开发的多个 mutating webhook 有顺序依赖</li><li>D. validating webhook 依赖 mutating webhook 先执行</li></ul><p>正确答案： A C</p><h4 id=10-下面哪种失败会导致-pod-创建失败>10. 下面哪种失败会导致 pod 创建失败</h4><ul><li>A. pod validating webhook 失败</li><li>B. pod mutating webhook 失败</li><li>C. pod controller 业务逻辑失败</li><li>D. pod controller 更新状态失败</li></ul><p>正确答案： A B</p><h3 id=第-25-讲kubernetes-网络模型进阶>第 25 讲：Kubernetes 网络模型进阶</h3><h4 id=1flannel-hostgw-方案精髓是选以下哪个网卡上的-ip做非本地节点网段的-gw>1.Flannel-HostGW 方案精髓，是选以下哪个网卡上的 IP，做非本地节点网段的 GW</h4><ul><li>A. CNI</li><li>B. Node-NIC</li><li>C. Remote-CNI0</li><li>D. Remote-Node-Nic</li></ul><p>相关知识点： 对端网段选对端 node 网卡 IP 做 GW</p><p>正确答案： D</p><h4 id=2-不通过-nodeport-接口外部无法调用-kubernetes-的-service>2. 不通过 Nodeport 接口，外部无法调用 Kubernetes 的 Service。</h4><ul><li>正确</li><li>错误</li></ul><p>相关知识点： 还有其他办法，比如在某个节点插入外网卡，变成路由节点</p><p>正确答案： 错误</p><h4 id=3-容器里面必须有网络设备才能叫容器网络>3. 容器里面必须有网络设备才能叫容器网络。</h4><ul><li>正确</li><li>错误</li></ul><p>相关知识点： 还可以有用户态路径方案</p><p>正确答案： 错误</p><h4 id=4-常见的网络五元组元素包含-4-层协议类型号>4. 常见的网络五元组元素包含 4 层协议类型号。</h4><ul><li>正确</li><li>错误</li></ul><p>正确答案： 正确</p><h4 id=5ingress-机制就是来替换-service-的>5.Ingress 机制就是来替换 Service 的。</h4><ul><li>正确</li><li>错误</li></ul><p>相关知识点： 不是，其实更好的辅助组件，更好对接 Service</p><p>正确答案： 错误</p><h4 id=6pod-能且只能支持网络空间共享>6.Pod 能且只能支持网络空间共享。</h4><ul><li>正确</li><li>错误</li></ul><p>相关知识点： 还可以支持 ipc 等空间，可选</p><p>正确答案： 错误</p><h4 id=7iptables-类型的-network-policy-可以通杀一切带-bridge-的容器网络数据方案>7.Iptables 类型的 network policy 可以通杀一切带 Bridge 的容器网络数据方案。</h4><ul><li>正确</li><li>错误</li></ul><p>相关知识点： Bridge 不使能 br-call-Iptables 功能，则不能起作用</p><p>正确答案： 错误</p><h4 id=8underlay-方案全面优于-overlay-方案可以完全替代>8.Underlay 方案全面优于 Overlay 方案，可以完全替代。</h4><ul><li>正确</li><li>错误</li></ul><p>相关知识点： 不是，要看场景</p><p>正确答案： 错误</p><h4 id=9-有了-service云厂商的负载均衡服务不再有用武之地>9. 有了 Service，云厂商的负载均衡服务不再有用武之地。</h4><ul><li>正确</li><li>错误</li></ul><p>相关知识点： 不是，云厂商 LB 服务是 Servier 的最佳前端</p><p>正确答案： 错误</p><h4 id=10docker-的桥接网络优势是什么>10.Docker 的桥接网络优势是什么</h4><ul><li>A. 天然集成在 Docker 引擎中</li><li>B. 与外部网络完全解耦</li><li>C. 能完美支持 Kubernetes 网络模型</li><li>D. Bridge 是内核最通用稳定的虚拟设备之一</li></ul><p>正确答案： A B D</p><h3 id=第-26-讲理解-cni-和-cni-插件>第 26 讲：理解 CNI 和 CNI 插件</h3><h4 id=1kubernetes-的网络插件接口是什么>1.Kubernetes 的网络插件接口是什么</h4><ul><li>A. CNI</li><li>B. CSI</li><li>C. CNM</li><li>D. CRI</li></ul><p>正确答案： A</p><h4 id=2-以下哪个不是路由模式的-cni-插件>2. 以下哪个不是路由模式的 CNI 插件</h4><ul><li>A. flannel-hostgw</li><li>B. calico-bgp</li><li>C. contiv</li><li>D. flannel-alivpc</li></ul><p>正确答案： C</p><h4 id=3-在虚拟化的环境中一般选择哪种类型的网络插件>3. 在虚拟化的环境中一般选择哪种类型的网络插件</h4><ul><li>A. Overlay</li><li>B. Underlay</li><li>C. 路由</li></ul><p>正确答案： A</p><h4 id=4kubernetes-通过-grpc-接口调用网络插件>4.Kubernetes 通过 GRPC 接口调用网络插件。</h4><ul><li>正确</li><li>错误</li></ul><p>正确答案： 错误</p><h4 id=5overlay-模式实现的网络插件性能损失较大>5.Overlay 模式实现的网络插件性能损失较大。</h4><ul><li>正确</li><li>错误</li></ul><p>正确答案： 正确</p><h4 id=6overlay-模式对底层网络环境要求小>6.Overlay 模式对底层网络环境要求小。</h4><ul><li>正确</li><li>错误</li></ul><p>正确答案： 正确</p><h4 id=7cni-插件一般由-daemon-和-binary-两部分组成>7.CNI 插件一般由 Daemon 和 Binary 两部分组成。</h4><ul><li>正确</li><li>错误</li></ul><p>正确答案： 正确</p><h4 id=8cni-插件要负责的事情包括>8.CNI 插件要负责的事情包括</h4><ul><li>A. 给 Pod 配置网卡和 IP 等网络配置</li><li>B. 配置 K8S Service 的负载均衡</li><li>C. 配置 Network Policy</li><li>D. 打通 Pod 间网络的访问</li></ul><p>正确答案： A C D</p><h4 id=9-以下哪个是-underlay-网络模式的特点>9. 以下哪个是 Underlay 网络模式的特点</h4><ul><li>A. 性能好</li><li>B. Pod 创建速度快</li><li>C. 对底层网络无要求</li><li>D. 可以和集群外资源互联互通</li></ul><p>正确答案： A D</p><h4 id=10-下列哪些可以作为打通-node-间网络通道的手段>10. 下列哪些可以作为打通 Node 间网络通道的手段</h4><ul><li>A. Overlay 隧道</li><li>B. VPC 路由表</li><li>C. IP 按 Node 分段</li><li>D. BGP 路由</li></ul><p>正确答案： A B D</p><h3 id=第-27-讲kubernetes-安全之访问控制>第 27 讲：Kubernetes 安全之访问控制</h3><h4 id=1-下列哪个选项不属于-kubernetes-api-请求流程>1. 下列哪个选项不属于 Kubernetes API 请求流程</h4><ul><li>A. authentication</li><li>B. authorization</li><li>C. autoscaling</li><li>D. admission control</li></ul><p>正确答案： C</p><h4 id=2-在-x509-证书认证中下列哪个字段会被-apiserver-作为用户模型中的用户-user>2. 在 x509 证书认证中，下列哪个字段会被 apiserver 作为用户模型中的用户 (user)</h4><ul><li>A. Issuer –> O</li><li>B. Issuer -> CN</li><li>C. Subject -> O</li><li>D. Subject -> CN</li></ul><p>正确答案： D</p><h4 id=3-以下哪种说法是错误的>3. 以下哪种说法是错误的</h4><ul><li>A. service account 是 Kubernetes 中唯一能够通过 API 方式管理的 apiserver 访问凭证</li><li>B. 对于已经创建的 pod，我们可以更新其已经挂载的 service account 内容</li><li>C. 用户可以通过 API 创建自定义名称的 service account</li><li>D. 当一个 namespace 创建完成后，会同时在该 namespace 下生成名为 default 的一个 Service Account 和对应的 secret 实例</li></ul><p>正确答案： B</p><h4 id=4-如果我们没有设置-kubeconfig-变量kubectl-客户端还会尝试从下列哪个路径读取-kubeconfig-配置>4. 如果我们没有设置 KUBECONFIG 变量，kubectl 客户端还会尝试从下列哪个路径读取 kubeconfig 配置</h4><ul><li>A. $HOME/.kube/config</li><li>B. $HOME/.config/kubeconfig</li><li>C. $HOME/.config/userconfig</li><li>D. $HOME/.kube/user</li></ul><p>正确答案： A</p><h4 id=5-下列哪种认证方式是安全上不推荐的方式>5. 下列哪种认证方式是安全上不推荐的方式</h4><ul><li>A. Basic 认证</li><li>B. x509 证书认证</li><li>C. OpenID Connect 认证</li><li>D. Service Account 认证</li></ul><p>正确答案： A</p><h4 id=6-下列哪个组件配置参数用于调整-kubernetes-中-certificatesigningrequest-实例签发证书的过期时间>6. 下列哪个组件配置参数用于调整 Kubernetes 中 CertificateSigningRequest 实例签发证书的过期时间</h4><ul><li>A. kube-apiserver -> tls-cert-file</li><li>B. kube-apiserver -> client-ca-file</li><li>C. kube-controller-manager -> experimental-cluster-signing-duration</li><li>D. kubelet -> rotate-certificates</li></ul><p>正确答案： C</p><h4 id=7rbac-中集群角色-clusterrole-可以绑定到-namespace-中的一个具体的-object-实例>7.RBAC 中集群角色 ClusterRole 可以绑定到 namespace 中的一个具体的 object 实例。</h4><ul><li>正确</li><li>错误</li></ul><p>正确答案： 错误</p><h4 id=8-在一个-rolebinding-实例中一个绑定只能指定唯一的-role>8. 在一个 RoleBinding 实例中，一个绑定只能指定唯一的 Role。</h4><ul><li>正确</li><li>错误</li></ul><p>正确答案： 正确</p><h4 id=9-下列关于-rbac-的说法哪些是正确的>9. 下列关于 RBAC 的说法，哪些是正确的</h4><ul><li>A. RBAC 策略模型中的 Subjects 可能包含开发人员，管理员，系统组件进程或是 pod 进程</li><li>B. RBAC 策略模型中的对象资源在 k8s 集群中指 Pod，Deployment 等各类 API 资源</li><li>C. RBAC 策略模型中的 Verbs 包括 list，watch，put 等</li><li>D. RBAC 策略模型中的角色可以对 k8s subresources（比如 nodes/status） 进行绑定</li></ul><p>正确答案： A B D</p><h4 id=10-为了请求主体能够有权使用-kubectl-exec-it-pod-test-bash在主体绑定的角色模板中需要加入如下哪些策略>10. 为了请求主体能够有权使用 kubectl exec –it pod-test bash，在主体绑定的角色模板中需要加入如下哪些策略</h4><ul><li>A. deployment： create</li><li>B. pods： get</li><li>C. service：create</li><li>D. pod/exec：create</li></ul><p>正确答案： B D</p><h3 id=第-28-讲容器运行时接口-cri>第 28 讲：容器运行时接口 CRI</h3><h4 id=1kubernetes-中crictl-是什么>1.Kubernetes 中，crictl 是什么</h4><ul><li>A. CRI 接口的性能测试工具</li><li>B. 操作 CRI 接口的命令行工具</li><li>C. CRI 接口的功能正确性测试工具</li></ul><p>正确答案： B</p><h4 id=2kubernetes-的容器运行时接口英文简写是什么>2.Kubernetes 的容器运行时接口英文简写是什么</h4><ul><li>A. CNI</li><li>B. CSI</li><li>C. CRI</li></ul><p>正确答案： C</p><h4 id=3kubernetes-中rkt-是什么>3.Kubernetes 中，rkt 是什么</h4><ul><li>A. 是一种容器运行时</li><li>B. 是一种网络插件</li><li>C. 是一个调度器</li></ul><p>正确答案： A</p><h4 id=4kubelet-与-cri-之间通过什么协议进行通信>4.Kubelet 与 CRI 之间通过什么协议进行通信</h4><ul><li>A. gRPC</li><li>B. HTTP/RESTful API</li><li>C. UDP</li></ul><p>正确答案： A</p><h4 id=5cri-o-是哪个公司的开源产品>5.CRI-O 是哪个公司的开源产品</h4><ul><li>A. Google</li><li>B. Red Hat</li><li>C. Vmware</li><li>D. AWS</li></ul><p>正确答案： B</p><h4 id=6-在-cri-的实现过程中需要进行-cni-操作>6. 在 CRI 的实现过程中，需要进行 CNI 操作。</h4><ul><li>正确</li><li>错误</li></ul><p>相关知识点： 创建和删除 POD 的时候，需要调用 CNI 设置网络</p><p>正确答案： 正确</p><h4 id=7pausecontainer-是一个-cri-接口>7.PauseContainer 是一个 CRI 接口。</h4><ul><li>正确</li><li>错误</li></ul><p>相关知识点： Kubernetes 不支持 pause 语义</p><p>正确答案： 错误</p><h4 id=8grpc-协议的优点是>8.gRPC 协议的优点是</h4><ul><li>A. 高性能</li><li>B. 有多种语言的实现</li><li>C. 可以自动生成接口代码</li><li>D. 支持双向流数据</li></ul><p>正确答案： A B C D</p><h4 id=9cri-有哪几类接口>9.CRI 有哪几类接口</h4><ul><li>A. Sandbox</li><li>B. Container</li><li>C. Image</li><li>D. Storage</li></ul><p>相关知识点： 存储不属于 CRI 的范畴</p><p>正确答案： A B C</p><h4 id=10-如何对-cri-进行拓展>10. 如何对 CRI 进行拓展</h4><ul><li>A. 直接修改 CRI 接口定义</li><li>B. 通过 annotation 传递自定义字段，在容器运行时的实现里识别</li><li>C. 修改 controller-manager 代码</li></ul><p>正确答案： A B</p><h3 id=第-29-讲安全容器运行时>第 29 讲：安全容器运行时</h3><h4 id=1kata-containers-从哪个版本开始支持-shim-v2-的>1.Kata Containers 从哪个版本开始支持 shim-v2 的</h4><ul><li>A. 1.2</li><li>B. 1.5</li><li>C. 1.6</li><li>D. 1.9</li></ul><p>相关知识点： 这个幻灯片里没有，但讲课的时候提了，这个应该很难记住</p><p>正确答案： B</p><h4 id=2virtio-fs-应用了哪项技术可以跨沙箱共享只读内存>2.virtio-fs 应用了哪项技术可以跨沙箱共享只读内存</h4><p>A. DDX</p><p>B. DAX</p><p>C. SGX</p><p>D. DFX</p><p>相关知识点： DAX，为非易失内存开发的技术</p><p>正确答案： B</p><h4 id=3kata-containers-项目是哪年宣布的>3.Kata Containers 项目是哪年宣布的</h4><ul><li>A. 2015</li><li>B. 2016</li><li>C. 2017</li><li>D. 2018</li></ul><p>正确答案： C</p><h4 id=4gvisor-是用什么语言编写的>4.gVisor 是用什么语言编写的</h4><ul><li>A. Go</li><li>B. Rust</li><li>C. Kotlin</li><li>D. Scala</li></ul><p>相关知识点： Go, Go 语言和 gVisor 都来自 G 开头的 Google</p><p>正确答案： A</p><h4 id=5gvisor-把什么操作交给-gofer-进程来进行>5.gVisor 把什么操作交给 Gofer 进程来进行</h4><ul><li>A. Go 代码执行</li><li>B. 冷门系统调用</li><li>C. 内存管理</li><li>D. 文件操作</li></ul><p>相关知识点： 最常见的是文件的 open 操作</p><p>正确答案： D</p><h4 id=6-在使用-kata-containers-的时候一个-pod-里面可以有几个容器>6. 在使用 Kata Containers 的时候，一个 Pod 里面可以有几个容器</h4><ul><li>A. 只能有一个</li><li>B. 可以有若干个 init container 和一个应用 container</li><li>C. 可以有一个 container 和一个 sidecar</li><li>D. 可以有多个 container</li></ul><p>正确答案： D</p><h4 id=7-安全容器和-runc-都可以运行-oci-image>7. 安全容器和 runC 都可以运行 OCI Image。</h4><ul><li>正确</li><li>错误</li></ul><p>相关知识点： 是的，都支持 OCI 规范</p><p>正确答案： 正确</p><h4 id=8-最早的容器技术-solaris-zone-在上个世纪的-1999-年就出现了>8. 最早的容器技术 Solaris Zone 在上个世纪的 1999 年就出现了。</h4><ul><li>正确</li><li>错误</li></ul><p>相关知识点： 可能还在脑子里吧，1999 年出现的是 FreeBSD Jail</p><p>正确答案： 错误</p><h4 id=9kata-containers-目前可以支持下列哪些虚拟机监视器vmm>9.Kata Containers 目前可以支持下列哪些虚拟机监视器（VMM）</h4><ul><li>A. VMWare</li><li>B. Qemu</li><li>C. Xen</li><li>D. Hyper-V</li><li>E. Firecracker</li></ul><p>正确答案： B E</p><h4 id=10-下列哪种机制被-gvisor-用来拦截容器的-syscall>10. 下列哪种机制被 gVisor 用来拦截容器的 syscall</h4><ul><li>A. ptrace</li><li>B. KVM</li><li>C. dtrace</li><li>D. strace</li><li>E. JVM</li></ul><p>相关知识点： 其他几个都是过来陪跑的，但是这个需要拓展学习以下</p><p>正确答案： A B</p><h3 id=第-30-讲理解-runtimeclass-与使用多容器运行时>第 30 讲：理解 RuntimeClass 与使用多容器运行时</h3><h4 id=1-以下哪段配置表示-containerd-的默认容器运行时>1. 以下哪段配置表示 containerd 的默认容器运行时</h4><ul><li>A. plugins.cri.containerd.runtimes.runc</li><li>B. plugins.cri.containerd.runtimes.runv</li><li>C. plugins.cri.containerd.default_runtime</li></ul><p>正确答案： C</p><h4 id=2kubernetes-哪个版本引入了-runtimeclass>2.Kubernetes 哪个版本引入了 RuntimeClass</h4><ul><li>A. 1.10</li><li>B. 1.12</li><li>C. 1.14</li><li>D. 1.16</li></ul><p>正确答案： B</p><h4 id=3-删除-runtimeclass-后对已有的-pod-overhead-有影响吗>3. 删除 RuntimeClass 后，对已有的 Pod Overhead 有影响吗</h4><ul><li>A. 无</li><li>B. 有</li><li>C. 需要根据上下文判断</li></ul><p>正确答案： A</p><h4 id=4-如果使用-runtimeclass-的-overhead需要开启哪个-admisson>4. 如果使用 RuntimeClass 的 Overhead，需要开启哪个 admisson</h4><ul><li>A. ResourceQUota admission</li><li>B. RuntimeClass admisson</li><li>C. PodOverhead admission</li></ul><p>正确答案： B</p><h4 id=5pod-overhead-支持手动配置或更改>5.Pod Overhead 支持手动配置或更改。</h4><ul><li>正确</li><li>错误</li></ul><p>正确答案： 错误</p><h4 id=6runtimeclass-是-cluster-级别的资源>6.RuntimeClass 是 cluster 级别的资源。</h4><ul><li>正确</li><li>错误</li></ul><p>正确答案： 正确</p><h4 id=7-在没有配置-node-label-的情况下只要-pod-引用的-runtimeclass-配置了-schedulingpod-就一定会被调度到有对应容器运行时的节点上>7. 在没有配置 node label 的情况下，只要 Pod 引用的 RuntimeClass 配置了 Scheduling，Pod 就一定会被调度到有对应容器运行时的节点上。</h4><ul><li>正确</li><li>错误</li></ul><p>正确答案： 错误</p><h4 id=8-哪些容器运行时是基于-cri-实现的>8. 哪些容器运行时是基于 CRI 实现的</h4><ul><li>A. gVisor</li><li>B. rkt</li><li>C. kata</li><li>D. docker</li></ul><p>正确答案： A C</p><h4 id=9pod-overhead-会影响哪些功能>9.Pod Overhead 会影响哪些功能</h4><ul><li>A. HPA</li><li>B. Pod 调度</li><li>C. ResourceQuota</li><li>D. Kubelet Pod 驱逐</li></ul><p>正确答案： B C D</p><h4 id=10-以下哪些是-kubernetes-v116-版本新增特性>10. 以下哪些是 Kubernetes v1.16 版本新增特性</h4><ul><li>A. Pod Overhead</li><li>B. Handler</li><li>C. Scheduling</li></ul><p>正确答案： A C</p></div><div class=post-footer id=post-footer><div class=post-info><div class=post-info-line><div class=post-info-mod><span>更新于 2019-11-14</span></div><div class=post-info-license></div></div><div class=post-info-line><div class=post-info-md><span><a class=link-to-markdown href=https://www.elonzh.com/cncf-alibaba-%E4%BA%91%E5%8E%9F%E7%94%9F%E6%8A%80%E6%9C%AF%E5%85%AC%E5%BC%80%E8%AF%BE%E6%B5%8B%E8%AF%95%E7%AD%94%E6%A1%88/index.md target=_blank>阅读原始文档</a></span></div><div class=post-info-share><span><a href=javascript:void(0); title="分享到 Twitter" data-sharer=twitter data-url=https://www.elonzh.com/cncf-alibaba-%E4%BA%91%E5%8E%9F%E7%94%9F%E6%8A%80%E6%9C%AF%E5%85%AC%E5%BC%80%E8%AF%BE%E6%B5%8B%E8%AF%95%E7%AD%94%E6%A1%88/ data-title="CNCF × Alibaba 云原生技术公开课测试答案" data-hashtags=CNCF,CKA><i class="fab fa-twitter fa-fw"></i></a><a href=javascript:void(0); title="分享到 Facebook" data-sharer=facebook data-url=https://www.elonzh.com/cncf-alibaba-%E4%BA%91%E5%8E%9F%E7%94%9F%E6%8A%80%E6%9C%AF%E5%85%AC%E5%BC%80%E8%AF%BE%E6%B5%8B%E8%AF%95%E7%AD%94%E6%A1%88/ data-hashtag=CNCF><i class="fab fa-facebook-square fa-fw"></i></a><a href=javascript:void(0); title="分享到 WhatsApp" data-sharer=whatsapp data-url=https://www.elonzh.com/cncf-alibaba-%E4%BA%91%E5%8E%9F%E7%94%9F%E6%8A%80%E6%9C%AF%E5%85%AC%E5%BC%80%E8%AF%BE%E6%B5%8B%E8%AF%95%E7%AD%94%E6%A1%88/ data-title="CNCF × Alibaba 云原生技术公开课测试答案" data-web><i class="fab fa-whatsapp fa-fw"></i></a><a href=javascript:void(0); title="分享到 Line" data-sharer=line data-url=https://www.elonzh.com/cncf-alibaba-%E4%BA%91%E5%8E%9F%E7%94%9F%E6%8A%80%E6%9C%AF%E5%85%AC%E5%BC%80%E8%AF%BE%E6%B5%8B%E8%AF%95%E7%AD%94%E6%A1%88/ data-title="CNCF × Alibaba 云原生技术公开课测试答案"><i data-svg-src=https://www.elonzh.com/lib/simple-icons/icons/line.min.svg></i></a><a href=javascript:void(0); title="分享到 微博" data-sharer=weibo data-url=https://www.elonzh.com/cncf-alibaba-%E4%BA%91%E5%8E%9F%E7%94%9F%E6%8A%80%E6%9C%AF%E5%85%AC%E5%BC%80%E8%AF%BE%E6%B5%8B%E8%AF%95%E7%AD%94%E6%A1%88/ data-title="CNCF × Alibaba 云原生技术公开课测试答案"><i class="fab fa-weibo fa-fw"></i></a><a href=javascript:void(0); title="分享到 Myspace" data-sharer=myspace data-url=https://www.elonzh.com/cncf-alibaba-%E4%BA%91%E5%8E%9F%E7%94%9F%E6%8A%80%E6%9C%AF%E5%85%AC%E5%BC%80%E8%AF%BE%E6%B5%8B%E8%AF%95%E7%AD%94%E6%A1%88/ data-title="CNCF × Alibaba 云原生技术公开课测试答案" data-description><i data-svg-src=https://www.elonzh.com/lib/simple-icons/icons/myspace.min.svg></i></a><a href=javascript:void(0); title="分享到 Blogger" data-sharer=blogger data-url=https://www.elonzh.com/cncf-alibaba-%E4%BA%91%E5%8E%9F%E7%94%9F%E6%8A%80%E6%9C%AF%E5%85%AC%E5%BC%80%E8%AF%BE%E6%B5%8B%E8%AF%95%E7%AD%94%E6%A1%88/ data-title="CNCF × Alibaba 云原生技术公开课测试答案" data-description><i class="fab fa-blogger fa-fw"></i></a><a href=javascript:void(0); title="分享到 Evernote" data-sharer=evernote data-url=https://www.elonzh.com/cncf-alibaba-%E4%BA%91%E5%8E%9F%E7%94%9F%E6%8A%80%E6%9C%AF%E5%85%AC%E5%BC%80%E8%AF%BE%E6%B5%8B%E8%AF%95%E7%AD%94%E6%A1%88/ data-title="CNCF × Alibaba 云原生技术公开课测试答案"><i class="fab fa-evernote fa-fw"></i></a></span></div></div></div><div class=post-info-more><section class=post-tags><i class="fas fa-tags fa-fw"></i>&nbsp;<a href=https://www.elonzh.com/tags/cncf/>CNCF</a>,&nbsp;<a href=https://www.elonzh.com/tags/cka/>CKA</a></section><section><span><a href=javascript:void(0); onclick=window.history.back();>返回</a></span>&nbsp;|&nbsp;<span><a href=https://www.elonzh.com/>主页</a></span></section></div><div class=post-nav><a href=https://www.elonzh.com/peeweext-%E6%97%A5%E6%9C%9F%E6%97%B6%E9%97%B4%E6%88%B3%E7%B2%BE%E5%BA%A6%E4%B8%A2%E5%A4%B1%E9%97%AE%E9%A2%98/ class=prev rel=prev title="Peeweext 日期时间戳精度丢失问题"><i class="fas fa-angle-left fa-fw"></i>Peeweext 日期时间戳精度丢失问题</a>
<a href=https://www.elonzh.com/celery-%E6%98%AF%E5%A6%82%E4%BD%95%E8%B7%AF%E7%94%B1%E6%B6%88%E6%81%AF%E7%9A%84/ class=next rel=next title="Celery 是如何路由消息的">Celery 是如何路由消息的<i class="fas fa-angle-right fa-fw"></i></a></div></div><div id=comments><div id=disqus_thread class=comment></div><noscript>Please enable JavaScript to view the comments powered by <a href=https://disqus.com/?ref_noscript>Disqus</a>.</noscript></div></article></div></main><footer class=footer><div class=footer-container><div class=footer-line>由 <a href=https://gohugo.io/ target=_blank rel="noopener noreffer" title="Hugo 0.68.3">Hugo</a> 强力驱动 | 主题 - <a href=https://github.com/dillonzq/LoveIt target=_blank rel="noopener noreffer" title="LoveIt 0.2.10"><i class="far fa-kiss-wink-heart fa-fw"></i>LoveIt</a></div><div class=footer-line><i class="far fa-copyright fa-fw"></i><span itemprop=copyrightYear>2019 - 2022</span><span class=author itemprop=copyrightHolder>&nbsp;<a href=https://www.elonzh.com/ target=_blank>Elon Zhou</a></span>&nbsp;|&nbsp;<span class=license><a rel="license external nofollow noopener noreffer" href=https://creativecommons.org/licenses/by-nc/4.0/ target=_blank>CC BY-NC 4.0</a></span><span class=icp-splitter>&nbsp;|&nbsp;</span><br class=icp-br><span class=icp>皖ICP备15003561号-2</span></div></div></footer></div><div id=fixed-buttons><a href=# id=back-to-top class=fixed-button title=回到顶部><i class="fas fa-arrow-up fa-fw"></i></a><a href=# id=view-comments class=fixed-button title=查看评论><i class="fas fa-comment fa-fw"></i></a></div><link rel=stylesheet href=https://www.elonzh.com/lib/katex/katex.min.css><link rel=stylesheet href=https://www.elonzh.com/lib/katex/copy-tex.min.css><link rel=stylesheet href=https://www.elonzh.com/lib/cookieconsent/cookieconsent.min.css><script type=text/javascript src=https://elonzh.disqus.com/embed.js defer></script><script type=text/javascript src=https://www.elonzh.com/lib/smooth-scroll/smooth-scroll.min.js></script><script type=text/javascript src=https://www.elonzh.com/lib/autocomplete/autocomplete.min.js></script><script type=text/javascript src=https://www.elonzh.com/lib/lunr/lunr.min.js></script><script type=text/javascript src=https://www.elonzh.com/lib/lunr/lunr.stemmer.support.min.js></script><script type=text/javascript src=https://www.elonzh.com/lib/lunr/lunr.zh.min.js></script><script type=text/javascript src=https://www.elonzh.com/lib/lazysizes/lazysizes.min.js></script><script type=text/javascript src=https://www.elonzh.com/lib/clipboard/clipboard.min.js></script><script type=text/javascript src=https://www.elonzh.com/lib/sharer/sharer.min.js></script><script type=text/javascript src=https://www.elonzh.com/lib/katex/katex.min.js></script><script type=text/javascript src=https://www.elonzh.com/lib/katex/auto-render.min.js></script><script type=text/javascript src=https://www.elonzh.com/lib/katex/copy-tex.min.js></script><script type=text/javascript src=https://www.elonzh.com/lib/katex/mhchem.min.js></script><script type=text/javascript src=https://www.elonzh.com/lib/cookieconsent/cookieconsent.min.js></script><script type=text/javascript>window.config={"code":{"copyTitle":"复制到剪贴板","maxShownLines":30},"comment":{},"cookieconsent":{"content":{"dismiss":"同意","link":"了解更多","message":"本网站使用 Cookies 来改善您的浏览体验."},"enable":true,"palette":{"button":{"background":"#f0f0f0"},"popup":{"background":"#1aa3ff"}},"theme":"edgeless"},"math":{"delimiters":[{"display":true,"left":"$$","right":"$$"},{"display":true,"left":"\\[","right":"\\]"},{"display":false,"left":"$","right":"$"},{"display":false,"left":"\\(","right":"\\)"}],"strict":false},"search":{"highlightTag":"em","lunrIndexURL":"/index.json","lunrLanguageCode":"zh","lunrSegmentitURL":"/lib/lunr/lunr.segmentit.js","maxResultLength":10,"noResultsFound":"没有找到结果","snippetLength":50,"type":"lunr"}};</script><script type=text/javascript src=https://www.elonzh.com/js/theme.min.js></script></body></html>